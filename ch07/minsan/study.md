# Chapter 07: 코드를 오용하기 어렵게 만들어라

# 7.1 불변 객체로 만드는 것을 고려하라

> 객체가 생성된 후에 상태를 바꿀 수 없다면, 이는 `불변 객체`이다.

불변성이 바람직한 이유를 설명하기 위해 가변 객체가 어떻게 문제를 일으킬 수 있는지 고려해야 한다.

기본적으로는 불변적인 객체를 만들되, 필요한 곳에서만 가변적이 되도록 하는 것이 바람직하다.

- **상태 변화를 추적해야 하는** 경우, **가변적인 자료구조**가 필요

### 가변 객체는 추론하기 어렵다

객체가 불변이라면, 객체를 여기저기에 전달하더라도 **어디에서도 그 객체가 변경되지 않았다는 것**을 확신할 수 있다.

### 가변 객체는 다중 스레드에서 문제가 발생할 수 있다

객체가 가변적이면 해당 객체를 사용하는 다중 스레드 코드가 특히 취약할 수 있다.

## 7.1.1 가변 클래스는 오용하기 쉽다

가변 클래스의 경우 일반적으로 `setter` 메서드를 포함한다.  
하지만 이러한 `setter` 메서드로 인해 필드 값이 예상치 못한 방향으로 변경될 가능성이 커진다.

> **'오브젝트'** 내용과 겹치는 부분  
> 👉🏻 결국 협력이라는 문맥 안에서 설계하지 않으면, 객체를 오용할 수밖에 없음

## 7.1.2 해결책: 객체를 생성할 때만 값을 할당하라

모든 값이 객체의 생성 시에 제공되고, 그 이후로는 변경할 수 없도록 한다. _(ex. `final` 키워드)_

만약 특정 값이 변경되어야 한다면, **변경된 값을 가지는 새로운 객체**를 반환하여 불변성을 보장한다.

## 7.1.3 해결책: 불변성에 대한 디자인 패턴을 사용하라

하지만 **일부 값이 반드시 필요하지 않거**나 **불변적인 클래스의 가변적 버전을 만들어야 하는** 경우 활용할 수 있는 디자인 패턴이 존재한다.

- 빌더 패턴
- 쓰기 시 복사 패턴 _(copy-on-write)_

### 빌더 패턴

클래스를 구성할 수 있는 **일부 값이 선택 사항**인 경우, `setter` 함수를 추가하여 클래스를 변경할 수 있도록 만드는 것보다, **`빌더 패턴`을 사용하는 것이 더 낫다.**

> `오브젝트 5장`에 따르면, _"경우에 따라 클래스의 일부 필드만 사용되는 경우에는 응집도가 낮은 것"_ 이라고 언급한 부분이 있다.
>
> 이처럼 **특정 값이 불필요한 경우**가 존재하는 것은 `vo 객체`에서만 가능하지 않을까 라는 생각이 든다.
>
> - 단순히 값이 아닌 **협력 내의 특정 역할을 갖는 객체**에서 `빌더 패턴`을 사용하는 것은 곧 응집도가 낮다는 의미이기 때문에, 이 경우에는 `빌더 패턴`의 적용이 적합하지 않아 보인다.
> - 그보다는 응집력을 높일 수 있도록 설계를 바꾸는 것이 나을 것이다.

빌더 패턴에서는 **필수 멤버**를 `생성자`의 매개변수로 설정하고, **필수가 아닌 멤버**는 `setter` 함수로 설정한다.

```java
public class TextOptions {
    private final Font font;
    private final Double fontSize = null;

    TextOptions(Font font, Double fontSize) {
        this.font = font;
        this.fontSize = fontSize;
    }

    TextOptions(Font font) {
        this.font = font;
    }

    Font getFont() {
        return font;
    }

    Double getFontSize() {
        return fontSize;
    }
}

public class TextOptionsBuilder {
    private final Font font;
    private Double fontSize;

    TextOptionsBuilder(Font font) {
        this.font = font;
    }

    TextOptionsBuilder setFontSize(Double fontSize) {
        this.fontSize = fontSize;
        return this;
    }

    TextOptions build() {
        return new TextOptions(font, fontSize);
    }
}
```

> 빌더는 `setter` 함수를 통해 **필수적이지 않은 값**을 받음  
> **연쇄적으로 함수 호출**을 할 수 있도록 자신(= 빌더 객체)을 리턴함

`빌더 패턴`은 **값의 일부가 선택사항**일 때, `불변적 객체`를 만드는 매우 유용한 방법이다.

### copy on write 패턴

클래스의 인스턴스를 변경해야 하는 경우도 존재한다.

> 인스턴스를 변경하면서도 **기존의 객체를 변경할 수 없도록** 하는 방법이 바로 `copy on write 패턴`이다.

즉, 인스턴스 변경 메서드에서 필드가 변경된 새로운 인스턴스를 반환한다.

- `Money`라는 불변 객체를 만든다고 가정
  - `Money minus(int value)`와 같이 덧셈/뺄셈 연산의 결과로 새로운 객체를 리턴하는 방법

# 7.2 객체를 깊은 수준까지 불변적으로 만드는 것을 고려하라

컬렉션과 같이 가변적인 유형의 필드 값에 유의해야 한다.

## 7.2.1 깊은 가변성은 오용을 초래할 수 있다.

## 7.2.2 해결책: 방어적으로 복사하라

클래스가 생성되거나 `getter`를 사용하는 경우, 필드의 원본 값이 아닌 복사본을 리턴한다.  
하지만 이 방식은 단점이 존재하기도 한다.

- 복사 비용이 크게 들 수 있음
- 클래스 내부에서 발생하는 변경을 막아주지 못함
  - 꼭 불변 자료구조가 아니더라도, `일급 컬렉션`으로도 이를 막을 수 있지 않을까라는 생각이 듦

## 7.2.3 해결책: 불변적 자료구조를 사용하라

java의 경우, 구아바 라이브러리의 `ImmutableList` 자료구조를 사용할 수 있다.

- 하지만 앞서 언급했듯이, `일급 컬렉션`을 사용하면 이 문제를 충분히 해결할 수 있다고 생각함

# 7.3 지나치게 일반적인 데이터 유형을 피하라

## 7.3.1 지나치게 일반적인 데이터 유형은 오용을 초래할 수 있다.

## 7.3.2 페어 유형은 오용하기 쉽다

## 7.3.3 해결책: 전용 유형 사용

요구사항에 맞는 전용 클래스를 정의해서 사용해라

# 7.4 시간 처리

시간 데이터는 직접 클래스로 정의해서 사용하기 매우 까다롭기 때문에, 기본적으로 제공하는 라이브러리를 사용하는 것이 현명하다

- ex) `Duration`, `LocalTime` ...

# 7.5 데이터에 대해 진실의 원천을 하나만 가져야 한다.

특정 데이터가 기존에 존재하는 데이터들의 조합으로 파생되는 경우, 이를 분산해서 관리하면 안된다는 의미임

> 예를들어 `A 필드`, `B 필드`, `C 필드`(= A + B) 보다는 `A 필드`, `B 필드`만 갖도록 하는 것

# 7.6 논리에 대한 진실의 원천을 하나만 가져야 한다.

여러 함수의 호출로 목표 데이터를 충분히 구할 수 있다면, 이를 하나의 클래스에서 모두 관리하는 것이 좋다.

> 즉, 각각의 함수를 서로 다른 클래스에서 관리하는 것보다 하나의 클래스에서 모두 구현하는 것이 좋다
