# Chapter3: 다른 개발자와 코드 계약

코드가 빈번히 변경되더라도 코드는 고품질로 유지되어야 한다.  
이를 위해서는 다른 개발자가 변경하거나 코드와 상호작용할 때 발생할 수 있는 문제는 없는지, 또 발생한다면 그 문제를 어떻게 완화할 수 있을지 이해하고 선제 조치하는 것이다.

## 1. 자신의 코드와 다른 개발자의 코드

### 1-1. 자신에게 분명하다고 해서 다른 사람에게도 분명한 것은 아니다.

코드를 처음 읽는 사람이 코드를 이해할 수 있도록, 아래 세 가지 항목을 설명해야 한다.

- 코드가 어떻게 사용되어야 하는지
- 무엇을 하는지
- 왜 그 일을 하고 있는지

> 하지만, 이를 주석으로만 해결하는 것은 좋은 방법이 아니다. `코드 자체로 위 세 가지 항목을 명백하게 드러내는 것`이 중요하다.

### 1-2. 다른 개발자는 무의식중 코드를 망가뜨릴 수 있다.

협업 과정에서 다른 개발자에 의해 기존의 코드가 수정될 수 있다. 이는 다른 개발자의 코드 변경으로 인해 기존의 코드가 **작동되지 않거나 오용될 수 있다**는 것이다.

이를 대비하기 위해서는 문제 발생시 `컴파일이 중지`되거나 `테스트가 실패`하도록 코드를 작성해야 한다.

> 👉🏻 함수가 오용될 가능성을 고려하여, 테스트 코드를 습관적으로 작성하는 것이 중요하다는 의미로도 해석된다.

## 2. 코드 사용법을 어떻게 아는가?

작성된 코드를 어떻게 사용해야 하는지 알아내기 위해 개발자가 할 수 있는 것은 다음과 같다.

- ⭐️ 함수, 클래스, 열거형 등의 이름을 살핀다.
  - 명확한 작명이 필요한 이유
- ⭐️ 함수와 생성자의 매개변수 유형 또는 반환 값의 유형 같은 데이터 유형을 살핀다.
- 함수/클래스 수준의 문서나 주석문을 읽어본다.
- 직접 묻는다.
- 함수와 클래스의 자세한 구현 코드를 읽는다.

  - `추상화의 요점`은 **문제 해결의 세부 사항을 정확히 알지 못하더라도**, 하위 문제에 대한 해결책을 사용할 수 있어야 한다는 것이다.  
    ⭐️ 만약 코드를 사용하는 방법을 알기 위해 세부 구현 사항을 읽어야 한다면, 추상화 계층의 이점을 부정하는 것이 된다.

    > 👉🏻 이러한 경우, `추상화`를 도입할만한 상황임에도 도입되지 않은 상태인지 점검해볼 수 있다는 의미로 해석된다.

## 3. 코드 계약

코드 계약이란, **다른 사람들이 어떻게 코드를 사용할지**, **코드가 무엇을 할 것으로 기대할 수 있는지**에 대한 것이다.

- 선결 조건 _(parameter, status)_
  - 코드를 호출하기 전에 사실이어야 하는 것  
    ex) 시스템이 어떤 상태에 있어야 하는지, 코드에 입력되어야 하는 값
- 사후 조건 _(status, return value)_
  - 코드가 호출된 후에 사실이어야 하는 것  
    ex) 시스템이 새로운 상태에 놓인다, 반환되는 값
- 불변 사항
  - 코드가 호출되기 `전`과 `후`에 시스템 상태를 비교해서 변경되지 않아야 하는 사항

> 이러한 조건을 통해, 함수를 호출하는 개발자가 코드의 동작을 충분히 예측할 수 있어야 한다.  
> 이는 코드를 호출하는 사람에게
> **"무언가를 설정하거나 입력(= 선결 조건)을 제공해야 할 요건"** 을 부여하고,  
> **"호출 결과 일어날 일 혹은 반환될 값(= 사후 조건)에 대한 기대"** 를 갖게 한다.

### 3-1. 계약의 세부 조항

코드에서 계약을 정의할 때, `명확한 부분`과 `세부 조항`이 있다.

#### 명확한 부분 _(= 예측 가능한 부분)_

- 함수와 클래스 이름
- 인자 타입
- 반환 타입
- 검사 예외
  - 자바에만 있으며 4장에서 자세히 다룸

#### 세부 조항 _(= 예측이 어려운 부분)_

- 주석문과 문서
- 비검사 예외
  - 프로그래밍 언어에서 말하는 일반적인 예외를 의미함
  - ex) 몇 계층 아래에서 예외를 생성하지만, 상위 계층에서 이를 인지하지 못할 수 있다.

### 3-2. 세부 조항에 너무 의존하지 말 것

#### 세부 조항이 많은 코드

```java
public class UserSettings {
    public UserSettings() {
        // ...
    }

    // 이 함수를 사용해 설정이 올바르게 로드되기 전까지는 다른 어떤 함수도 호출될 수 없다.
    // 설정이 성공적으로 로드되면 참을 반환한다.
    Boolean loadSettings(File location) {
        // ...
    }

    // 다른 함수 호출 이전에 호출해야 하지만, loadSettings 함수 호출 이후에만 호출해야 한다.
    void init() {
        // ...
    }

    // 사용자가 선택한 UI의 색상을 반환한다.
    // 선택된 색상이 없거나, 설정이 로드되지 않았거나, 초기화되지 않은 상태면 널을 반환한다.
    Optional<Color> getUiColor() {
        // ...
    }
}
```

> 여기서도 특히 `getUiColor` 함수의 경우, **널 리턴 값**이 의미하는 바가 모호하게 해석될 여지가 크다. _(색상이 존재하지 않음 / 설정 오류)_

이러한 세부 조항은 **구현에 최대한 포함시키는 것**이 좋다.  
👉🏻 즉, 세부 조항에 의존하기보다는 **코드를 오용하는 것을 아예 불가능하게 만드는 것**이 좋다는 의미이다.

따라서 위의 코드는 아래와 같이 정적 팩토리 메서드를 사용하여 세부 조항을 구현에 포함시킬 수 있다.

```java
public class UserSettings {
    private UserSettings() {
        // ...
    }

    public static UserSettings create(File location) {
        UserSettings settings = new UserSettings();
        if (!settings.loadSettings(location)) {
            return null;
        }
        settings.init();
        return settings;
    }

    private Boolean loadSettings(File location) {
        // ...
    }

    private void init() {
        // ...
    }

    // 사용자가 선택한 UI 색상을 반환한다. 색상을 선택하지 않은 경우에는 널을 반환한다.
    public Color getUiColor() {
        // ...
    }
}
```

> `UserSettings` 클래스의 계약에서 거의 모든 숨겨진 세부 조항을 성공적으로 제거함으로써, 잘못된 상태의 인스턴스를 생성할 수 없도록 개선되었다.

- 상태와 가변성

  ```md
  [ 상태와 가변성의 외부 노출 없애기 ]

  - 객체의 상태
    👉🏻 객체가 담고 있는 어떤 값 / 데이터
  - 객체의 가변성
    👉🏻 객체의 상태를 수정할 수 있으면 `가변적`, 객체 생성 후 상태를 변경할 수 없으면 `불변적`

  코드 품질을 향상하기 위한 많은 방법은, 이 두 가지를 최소화 하는 것과 관련이 있다.
  :: 즉, 객체가 관리하는 값을 최소화하되 불변 값으로 정의하는 것이 코드 품질 향상에 도움이 된다는 의미로 해석된다.
  ```

## 4. 체크 및 어서션

컴파일러 _(타입 등)_ 를 사용하여 코드 계약을 확인하는 것의 대안으로 `런타임 검사`를 사용할 수 있다.

**컴파일러를 사용하여 계약을 강제할 수 있는 실질적 방법이 없는 상황**에서는, 이 방법을 사용하는 것이 좋다.

### 4-1. 체크

코드 계약의 준수 여부를 확인하기 위한 **추가적인 로직**으로서, 계약이 위반되었을 경우에는 `예외`를 생성한다.

> 👉🏻 예를들어 조건문을 통해 선결 조건 혹은 사후 조건을 확인(= 체크)하고, 이에 상응하지 않을 경우 예외를 처리하는 것

위의 예제에 `체크`를 적용하면 다음과 같다.

```java
public class UserSettings {
    public UserSettings() {
        // ...
    }

    // 이 함수를 사용해 설정이 올바르게 로드되기 전까지는 다른 어떤 함수도 호출될 수 없다.
    // 설정이 성공적으로 로드되면 참을 반환한다.
    boolean loadSettings(File location) {
        // ...
    }

    // 다른 함수 호출 이전에 호출해야 하지만, loadSettings 함수 호출 이후에만 호출해야 한다.
    public void init() {
        if (!haveSettingsBeenLoaded()) {
            throw new StateException("Settings not loaded");
        }
        // ...
    }

    // 사용자가 선택한 UI 색상을 반환한다. 색상을 선택하지 않은 경우에는 널을 반환한다.
    public Color getuiColor() {
        if (!hasBeenInitialized()) {
            throw new StateException("Settings not initialized");
        }
        // ...
    }
}
```

> 하지만 이 방식은 코드의 오용을 방지하는 것에는 크게 효과적이지 않다고 강조한다.

특히 **상위 수준에서 예외가 처리되는 경우**에는, 문제 상황을 인지하지 못할 가능성도 크다.  
👉🏻 세부 조항은 최대한 피하는 것이 바람직하다. 즉, 로직에 세부 사항을 포함하는 것이 좋다.

```
📒 코드에 체크가 많다면, 세부 조항을 없애는 것에 대해 고려해봐야 한다는 신호로 볼 수 있다.
```

### 4-2. 어서션 (assertion)

체크와의 차이점은 배포를 위해 빌드할 때 어서션은 보통 `컴파일에서 제외된다`는 점이다.  
👉🏻 실제 서비스 환경에서 사용될 때 실패를 명백히 보여주지 않는다.

> 결국에는 체크와 어서션을 사용하기 전에, 세부 사항을 구현에 포함할 수 있는지 먼저 살펴봐야 한다는 것이 요점인 것 같다.
