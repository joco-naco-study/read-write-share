# ch03 다른 개발자와 코드 계약

## 3.1 자신의 코드와 다른 개발자의 코드

코드를 작성할 때 다음 세 가지를 고려하는 것이 유용하다

- 자신에게 명백하다고 해서 다른 사람에게도 명백한 것은 아니다.
- 다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다.
- 시간이 지남에 따라 자신의 코드를 기억하지 못한다.

### 3.1.1자신에게 명백하다고 해서 다른 사람에게도 명백한 것은 아니다.

### 3.1.2 다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다.

### 3.1.3 시간이 지나면 자신의 코드를 기억하지 못한다.

## 3. 2 여러분이 작성한 코드의 사용법을 다른 사람들은 어떻게 아는가?

- 여러 가지 상황에서 어떤 함수를 호출해야 하는지
- 클래스가 무엇을 나타내는지 그리고 언제 사용되어야 하는지
- 어떤 값을 인수로 사용해야 하는지
- 코드가 수행하는 동작이 무엇인지
- 어떤 값을 반환하는지

여러분이 작성한 코드를 어떻게 사용해야 하는지 알아내기 위해 다른 개발자가 할 수 있는 일은 다음과 같다.

- 함수, 클래스, 열거형 등의 이름을 살펴본다.
- 함수와 생성자의 매개변수 유형 또는 반환값의 유형 같은 데이터 유형을 살펴본다.
- 함수/클래스 수준의 문서나 주석문을 읽어본다.
- 직접 와서 묻거나 채팅/이메일을 통해 문의한다.
- 여러분이 작성한 함수와 클래스의 자세한 구현 코드를 읽는다.

이 중 처음 세 가지만 실제로 사용할 만하고, 그중에서도 이름과 데이터 유형을 확인하는 것이 문서를 읽는 것보다 더 신뢰할 만하다.

### 3.2.1 이름 확인

이 이름들을 살펴보는 것은 하위 문제를 해결할 코드를 찾기 위한 편리하고 빠른 방법이다. 코드를 사용할 때 이름을 무시하기는 매우 어렵다. `removeEntry()`라는 이름의 함수는`addEntry()` 라는 이름의 함수와 혼동할 수 없다.

따라서 자신의 코드를 다른 개발자가 어떻게 사용해야 하는지에 대해 가장 잘 전달할 수 있는 방법 중 하나는 이름을 잘 짓는 것이다.

### 3.2.2 데이터 유형 확인

### 3.2.3 문서 읽기

- 함수 및 클래스 수준의 비공식적인 주석문
- 자바독 `javaDoc`과 같은 좀 더 공식적인 코드 내 문서
- 외부 문서(`READEME.md`, 웹 페이지, 지침 문서 등)

이 모든 것이 매우 유용하지만 다른 개발자가 코드를 올바르게 사용하도록 하기 위한 방법으로 어느정도까지만 신뢰할 수 있다.

- 다른 개발자가 이 문서들을 읽을 것이라는 보장이 없으며 실제로 읽지 않을 때가 많다.
- 설령 읽더라도 잘못 해석할 수 있다. 다른 개발자들이 익숙하지 않은 용어를 사용할 수도 있고, 코드가 해결하려는 문제에 관해 다른 개발자들이 가지고 있을 지식의 수준이나 정도에 대해 잘못된 가정을 바탕으로 문서를 작성할 수도 있다.
- 문서의 업데이트가 제대로 안 될 수 있다. 개발자가 코드를 변경할 때마다 문서를 업데이트해야 하는데 이것을 잊어버리면 코드에 대한 문서의 내용이 더 이상 유효하지 않게 된다.

### 3.2.4 직접 물어보기

- 코드를 많이 작성할수록 질문에 답하는 데 더 많은 시간을 써야 할 것이다. 결국에는 이 모든 질문에 답하기 위해 하루 중 몇 시간을 써야 할 수도 있다.
- 코드 작성자가 2주간 휴가를 간다면 코드에 대해 물어볼 사람이 없다.
- 1년이 지나면 자기 자신도 그 코드를 기억하지 못한다. 그래서 실제로는 이런 접근법은 어느 정도 제한된 기간 동안만 효과가 있다.
- 코드를 작성한 사람이 회사를 떠날 수도 있는데, 이 경우에는 코드를 사용하는 방법에 대한 지식이 사라져 버린다.

### 3.2.5 코드를 살펴보는 것

## 3.3 코드 계약

계약에 의한 프로그래밍`programming by contract` 또는 계약에 의한 디자인 `design by contract` 
이 원칙은 이전 절에서 논의한 개념들 중 일부를 공식화하는 원칙으로 다른 사람들이 어떻게 코드를 사용할지, 그리고 코드가 무엇을 할 것으로 기대할 수 있는지에 대한 것이다.

- 선결 조건`precondition` : 코드를 호출하기 전에 사실이어야 하는 것, 예를 들어 시스템이 어떤 상태에 있어야 하는지, 코드에 어떤 압력을 공급해야 하는지와 같은 사항
- 사후 조건`postcondition` : 코드가 호출된 후에 사실이어야 하는 것, 예를 들어 시스템이 새로운 상태에 놓인다든지 반환되는 값이 같은 사항
- 불변 사항`invariant` : 코드가 호출되기 전과 후에 시스템 상태를 비교해서 변경되지 않아야 하는 사항

### 3.3.1 계약의 세부 조항

#### 계약의 명확한 부분

- 함수와 클래스 이름: 호출하는 쪽에서 이것을 모르면 코드를 사용할 수 없다.
- 인자 유형: 호출하는 쪽에서 인자의 유형을 잘못 사용하면 코드는 컴파일조차 되지 않는다.
- 반환 유형: 호출하는 쪽에서 함수의 반환 유형을 알아햐 한다. 이 유형과 일치하지 않는 유형을 사용하면 코드는 컴파일되지 않는다.
- 검사 예외`checked exception` : 호출하는 코드가 이것을 처리하지 않으면 코드는 컴파일되지 않는다.

#### 세부 조항

- 주석문과 문서: 실제 계약의 세부 조항에 대해 그렇듯이 꼼꼼하게 모두 읽어봐야 하는 것임에도 실제로는 잘 읽지 않는다. 개발자는 이 사실을 실용적인 고나점에서 봐야 한다.
- 비검사 예외`unchecked exception` : 주석문에 이 예외가 나열되어 있다면 이것은 세부 조항이다. 어
  떤 떄는 심지어 세부 조항에도 나와 있지 않을 수도 있다. 예를 들어 몇 계층 아래에서 함수가 비검사 예외를 생성하지만 이 함수의 작성자가 문서에서 그것을 언급하는 것을 잊어버리는 경우다.

### 3.3.2 세부 조항에 너무 의존하지 말라

## 3. 4 체크 및 어서션 (assertion)

### 3.4.1 체크

### 3.4.2 어서션 (assertion)

## 요약

- 코드베이스는 계속 변하고 일반적으로 여러 개발자에 의해 변경된다.
- 다른 개발자가 어떻게 코드를 해석하고 오용할 수 있을지 생각해보고, 이러한 가능성을 최소화하거나 오용이 불가능하게 만드는 방식으로 코드를 작성하는 것이 유용하다.
- 코드를 작성할 때 일종의 코드 계약이 항상 만들어진다. 여기에는 명백한 항목이나 세부 조항과 같은 내용이 포함될 수 있다.
- 일반적으로 컴파일러를 사용하여 계약을 확인하는 것이 가장 신뢰할 수 있는 방법이다. 이것이 가능하지 않을 때, 체크나 어셔선을 사용하여 실행 시간에 계약을 확인할 수 있다.











