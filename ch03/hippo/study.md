# Chapter 3 - 다른 개발자와 코드 계약

## 자신의 코드와 다른 개발자의 코드

**자신이 작성한 코드가 독립적으로 존재하는 경우는 거의 없다!**

**다른 개발자들이 작성한 코드에 의존할 것이고, 다른 엔지니어들 또한 여러분의 코드에 의존하는 코드를 작성할 것이다.**


### 코드를 작성할 때 고려해볼 세 가지 사항

#### 1. 자신에게 명백하다고 해서 다른 사람에게도 명백한 것은 아니다.

코드를 작성할 당시에 너무도 분명해 보였던 것들이 다른 사람에게는 분명하지 않을 것이다!

이것을 항상 고려하고 코드가 어떻게 사용되어야 하는지, 무엇을 하는지, 그리고 왜 그 일을 하고 있는지 설명하는 것이 유용하다.

코드를 이해하기 쉽고 코드 자체로 설명이 되게 하는 것이 좋은 방법이다!


#### 2. 다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다.

다른 사람이 내가 작성한 코드를 접할 때 그 코드가 왜 존재하는지 혹은 무슨 일을 수행하는지에 대한 사전 시직을 가지고 있지 않을 수 있다.

이 경우 다른 개발자가 의도치 않게 잘 실행되던 코드를 작동하지 않게 하거나 오용하는 방식으로 코드를 추가하거나 수정할 가능성이 크다.

이를 방지하기 위해, 무언가 문제가 있을 때 코드 컴파일이 중지되거나 테스트가 실패하도록 만들어야한다.

코드에 문제가 생겼을 때, 위와 같은 일이 일어나도록 하는 것이 고품질 코드의 작성과 관련된 많은 고려 사항들이 궁극적으로 이루고자 하는 것이다.


#### 3. 시간이 지남에 따라 자신의 코드를 기억하지 못한다.

배경지식이 거의 없거나 전혀 없는 사람에게도 자신의 코드가 이해하기 쉬어야 한다.

잘 작동하던 코드에 버그가 발생하는 것이 어려워야 한다.

**이렇게 하는 것은 미래의 자신에게도 유익한 일이다.**



## 여러분이 작성한 코드의 사용법을 다른 사람들은 어떻게 아는가??

미래의 자신 또한 본질적으로 다른 개발자라고 간주하자!!

### 코드를 이해하기 위한 사항
1. 여러 가지 상황에서 어떤 함수를 호출해야 하는지
2. 클래스가 무엇을 나타내는지 그리고 언제 사용되어야 하는지
3. 코드가 수행하는 동작이 무엇인지
4. 어떤 값을 반환하는지


### 코드를 어떻게 사용해야 하는지 알아내기 위한 방법들

#### 이름 확인

- 패키지, 클래스, 함수의 이름을 살펴보는 것은 하위 문제를 해결할 코드를 찾기 위한 편리하고 빠른 방법

- 따라서 자신의 코드를 다른 개발자가 어떻게 사용행 하는지에 대햇 가장 잘 전달할 수 있는 방법 중 하나는 이름을 잘 짓는 것이다.


#### 데이터 유형 확인

- 컴파일이 필요한 정적 유형의 언어게서는 데이터 유형을 인식하고 올바르게 사용해야 하지 않으면 컴파일 되지 않는다.

- 따라서 유형 시스템을 사용하는 언어로 코드를 작성하는 것은 다른 개발자가 코드를 오용하거나 동작할 수 없도록 하기 위한 좋은 방법 중 하나이다.


#### 문서 읽기

- 주석문, JavaDoc, README.md 등...
- 다만, 해당 문서를 읽을 것이라는 보장이 없고 업데이트가 제대로 되지 않거나 문서를 잘못 이해할 수 있다.


**이외의 직접 물어보기, 코드 살펴보기 등 존재...**


## 코드 계약

코드에서 계약을 정의할 때도 명확한 부분과 세부 조항이 있다.

### 계약의 명확한 부분

- 함수와 클래스 이름, 인자 유형, 반환 유형, 검사 예외

### 세부 조항

- 주석문과 문서, 비검사 예외

코드 계약에서 조건을 명백하게 하는 것이 세부 조항을 사용하는 것보다 훨씬 낫다.

사람들은 세부 조항을 읽지 않는 경우가 매우 많으며, 심지어 읽더라도 그것을 대충 훑어보기 때문에 잘못 이해할 수 있다.

그리고 문서화는 업데이트가 제때 되지 않기 때문에 세부 조항이 항상 정확한 것도 아니다.


## 세부 조항에 너무 의존하지 말라

세부 조항에 너무 많이 의존하면 오용하기 쉬운 취약한 코드가 될 가능성이 크고, 예상과 다르게 동작하기 쉽다.

세부 조항에 의존하는 것을 피할 수 없는 상황도 있지만, 너무 많이 의존하지 않도록 해야한다.

코드 계약이 분명한 항목을 통해 코드에 관해 명확하게 설명하는 것이 가능하다면 그렇게 하는 것이 더 바람직할 때가 많다.

세부 조항이 많은 코드
```java
class UserSettings {
    UserSettings() { ... }
    
    // 이 함수를 사용해 설정이 올바르게 로드되기 전까지는 다른 어떤 함수도
    // 호출해서는 안된다.
    // 설정이 성공적으로 로드되면 참을 반환한다.
    Boolean loadSettings(File location) { ... }
    
    // init()은 다른 함수 호출 이전에 호출해야 하지만
    // loadSettings() 함수 호출 이후에만 호출해야 한다.
    void init() { ... }
    
    // 사용자가 선택한 UI의 색상을 반환한다.
    // 선택된 색상이 없거나, 설정이 로드되지 않았거나, 초기화되지 않은 상태면
    // 널을 반환한다.
    Color? getUiColor() { ... }
}
```

- 위 주석들과 같은 문서는 코드 계약의 세부 조항에 해당한다.
- geUiColor의 널 반환값은 두 가지 중 하나를 의미하는데, 사용자가 색상을 선택하지 않았거나 클래스가 완전히 초기화되지 못했음이다.

잠재적인 버그가 있는 코드
```java
void setUiColor(UserSettings userSettings) {
    Color? chosenColor = userSettings.getUiColor();
    if (chosenColor == null) {
        ui.setColor(DEFAULT_UI_COLOR);
        return;
    }
    ui.setColor(chosenColor);
}
```

- getUiColor()가 널값을 반환하면 기본 색상을 사용한다.
- 이것은 사용자가 색상을 선택하지 않았거나 UserSettings 클래스가 유효하지 못한 상태에 있을 때 일어날 수 있다.


위 클래스의 계약은 바람직하지 않다.

해당 클래스를 사용하는 개발자가 모든 세부 조항을 주의 깊게 읽지 않으면 올바른 설정을 하지 못할 가능성이 크다.

또한 코드에서 설정이 잘못 이루어지면 잠재적으로 버그를 발생시킬 가능성도 크다.

코드를 오용할 수 있는 방법이 많을수록 실제로 오용되고 소프트웨어에 버그가 있을 가능성이 크다.

## 세부 조항이 거의 없는 코드
```java
class UserSettings {
    // 생성자는 프라이빗이고 이로 인해 이 코드를 사용하는 다른 개발자는 생성자 대신 create()를 사용할 수밖에 없다.
    private UserSettings() {...}
    
    // Usersettings 클래스의 인스턴스를 만들기 위한 유일한 방법은 이 함수를 호출하는 것이다.
    public static UserSettings? create(File location) {
        UserSettings settings = new UserSettings();
        if (!settings.loadSettings(location)) {
            // 설정값을 로딩하는 것이 실패하면 널값을 반환한다.
            // 이렇게 함으로써 누구도 유효하지 않은 상태의 인스턴스를 가질 수 없다.
            // 널 안전성으로 인해 호출하는 코드는 실패 상황을 알 수 있다.
            // 프로그래밍 언어가 널 안전성을 지원하지 않으면 옵셔널 타입을 사용하기 바란다.
            return null;
        }
        settings.init();
        return settings;
    }
    
    // 클래스의 상태를 변경하는 함수는 다 프라이빗이다.
    private Boolean loadSettings(File location) {
        ...
    }
    
    private void init() {
        ...
    }
    
    // 반환되는 값이 널이면 사용자가 색상을 선택하지 않았다는 의미만을 갖는다.
    Color? getUiColor() { ... }
}
```

- UserSettings 클래스는 정적 팩토리 함수를 사용해 초기화가 완전히 이루어진 인스턴스를 얻는 것만 가능하도록 수정할 수 있다.

- 위와 같은 방법을 이용하면 어떤 상태 (state)나 가변성(mutability)이 클래스 외부로 노출되는 것을 없앤다.

> **상태와 가변성**
> 
> 객체를 만든 후 객체의 상태를 수정할 수 있으면 이 객체는 가변적 (mutable)이라 한다.
>
> 반대로 객체를 생성한 후에 상태를 변경할 수 없다면, 이 객체는 불변적 (immutable)이라고 한다.


**코드를 오용하는 것이 불가능하면 다른 개발자들이 그 코드를 사용할 때 버그가 침투할 가능성이 훨씬 낮아진다.**


## 체크 및 어서션

컴파일러를 사용하여 코드 계약을 확인하는 것에 대한 대안으로 런타임 검사를 사용할 수 있다.

해당 방법은 코드를 실행하는 동안 발생하는 문제에 대한 테스트에 의존하기 때문에 일반적으로 컴파일 타임 확인만큼 강력하지는 않지는 않다.

하지만 컴파일러를 사용하여 계약을 강제할 수 있는 실질적인 방법이 없는 상황일 경우 런타임 검사를 통해 계약을 확인하는 것이 아예 계약을 확인하지 않는 것보다 낫다.

### 체크

코드 계약 조건을 확인하기 위한 일반적인 방법은 체크를 사용하는 것이다.

체크는 실패를 유발하는 오류를 생성하는데, 이 실패는 명백해서 놓치고 넘어가는 것이 불가능하다.

- 전체 조건 검사
  - 예를 들어 입력 인수가 올바르거나, 초기화가 수행되었거나, 일부 코드를 실행하기 전에 시스템이 유효한 상태인지 확인하는 경우
- 사후 상태 검사
  - 예를 들어 반환값이 올바르거나 일부 코드를 실행한 후 시스템이 유효한 상태인지 확인하는 경우


계약 시행을 위한 체크 사용
```java
class UserSettings {
    UserSettings() {
        ...
    }

    // 이 함수를 사용해 설정이 올바르게 로드되기 전까지는 다른 어떤 함수도
    // 호출해서는 안된다.
    // 설정이 성공적으로 로드되면 참을 반환한다.
    bool loadSettings(File location) {
        ...
    }
    
    // init()은 다른 함수 호출 이전에 호출해야 하지만
    // loadSettings() 함수 호출 이후에만 호출해야 한다.
    void init() {
        if (!haveSettingsBeenLoaded()) {
            throw new StateException("Settings not loaded");
        }
        ...
    }
    
    // 사용자가 선택한 UI의 색상을 반환한다.
    // 선택된 색상이 없으면 널을 반환한다.
    Color? getUiColor() {
        if (!hasBeenInitialized()) {
            throw new StateException("Settings not initialized");
        }
    }
}
```
- 클래스가 유효하지 않은 방법으로 사용되면 예외가 발생한다.


### 체크를 사용할 때 기대하는 것

코드가 오용되면 고객에게 배포되거나 실제 프로덕션에서 서비스되기 전에 개발 단계나 테스트 단계에서 발견되고 수정되는 것이다.

이것은 프로그램이 아무도 눈치채지 못하게 유효하지 못한 상태로 들어가 이상한 버그가 발견되지만, 처음에는 명백하게 파악되지 않는 상황보다는 낫다.

그러나 체크의 효과가 보장되는 것은 아니다.


- 테스트하기가 불분명한 상황에서만 확인 중인 조건이 위반된다면, 코드가 배포되고 사용자가 사용하지 전까지 버그가 노출되지 않을 수 있다.
- 체크가 잘 작동해서 실패가 명백함게도 불구하고 아무도 알아차리지 못할 위험이 있다.

> 퍼즈 테스트
> 
> 코드나 소프트웨어의 버그나 잘못된 설정을 드러낼 수 있는 입력값을 생성해 테스트를 수행하는 테스트의 한 종류
> 
> 퍼즈 테스트를 사용하는 경우, 체크를 함께 사용하면 잘못된 설정이나 버그를 발견할 가능성을 높이는 데 도움이 된다.
> 
> 왜냐하면 퍼즈 테스트는 오류나 예외 발생에 의존하며 이것만으로는 단순히 이상한 동작을 초래하는 미묘한 버그를 발견할 수 없기 때문이다!


## 어서션 (assertion)

코드 계약을 준수하도록 강제하기 위한 방법.

코드가 개발 모드에서 컴파일 되거나 테스트가 실행될 때, 체크와 거의 같은 방식으로 동작한다!

**어서션과 체크의 차이?**

배포를 위해 빌드할 때 어서션은 보통 컴파일에서 제외된다는 점.

컴파일하지 않는 이유??

1. 성능 향상을 위해
2. 코드 오류 발생률을 낮추기 위해
   - 버그가 눈에 띄지 않을 가능성이 증가하지만 버그 발생 가능성 방지보다 고가용성이 더 중요한 시스템이라면 배포 시에 컴파일에서 제외하는 것은 적절한 절충안이 될 수 있다.

계약 시행을 위한 어서션 사용
```java
class UserSettings {
    ...
    // 사용자가 선택한 UI의 색상을 반환한다.
    // 선택한 색상이 없으면 널을 반환한다.
    Color? getUiColor() {
        assert(hasBeenInitialized(), "UserSettings가 초기화되지 않음");
    }
}
```

- 클래스가 유효하지 않은 방식으로 사용되면 어서션은 에러나 예외를 발생한다.


## 요악

- 코드베이스는 계속 변하고 일반적으로 여러 개발자에 의해 변경된다.
- 다른 개발자가 어떻게 코드를 해석하고 오용할 수 있을지 생각해보고, 이러한 가능성을 최소화하거나 오용이 불가능하게 만드는 방식으로 코드를 작성하는 것이 유용하다.
- 코드를 작성할 때 일종의 코드 계약이 항상 만들어진다. 여기에는 명백한 항목이나 세부 조항과 같은 내용이 포함될 수 있다.
- 코드 계약의 세부 조항은 다른 개발자가 계약을 준수하도록 하기 위한 방법이지만 신뢰할만한 방법은 아니다. 보통 더 나은 접근법은 명백한 항목으로 계약의 내용을 전달하는 것이다.
- 일반적으로 컴파일러를 사용하여 계약을 확인하는 것이 가장 신뢰할 수 있는 방법이다. 이것이 가능하지 않을 때, 체크나 어서션을 사용하여 실행 시간에 계약을 확인할 수 있다.