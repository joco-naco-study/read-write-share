> 핵심 내용은 `4-4`부터 나온다. 초반부 내용은 개념 설명 느낌임

# Chapter04: 오류

오류를 생각했을 때, `소프트웨어가 작동을 계속할 수 있는 오류`와 `작동을 멈춰야하는 오류`로 구분하는 것이 유용할 때가 많다.

이번 장에서는 둘의 차이점을 살펴보고, **오류가 눈에 띄지 않게 발생하지 않도록(= 눈에 띄도록)** 하고, **적절하게 처리되도록** 하기 위해 사용할 수 있는 기술을 논의한다.

## 4-1. 복구 가능성

### 1. 복구 가능한 오류

- 사용자 입력 오류
- 네트워크 오류
- 중요하지 않은 작업 오류

시스템 외부의 무언가에 의해 야기되는 오류에 대해서는 대부분 시스템 전체가 표나지 않고 적절히 처리하기 위해 노력해야 한다.

낮은 층위의 코드에서 오류를 시도하고 복구하는 것은 장점이 별로 없다.

> 👉🏻 오류 처리 방법을 알고 있는 **더 높은 층위의 코드로** 오류를 전송해야 하는 경우가 많다.

### 2. 복구 불가능한 오류

이는 프로그래밍 오류 때문에 발생할 때가 많다.

- 어떤 코드가 다른 코드를 잘못 사용하는 경우
  - 잘못된 입력 인수로 호출
  - 일부 필요한 상태를 사전에 초기화하지 않음

이때는 피해를 최소화하고, 개발자가 문제를 발견하고 해결할 가능성을 최대화 하는 것이다.

> 👉🏻 `신속한 실패`, `요란한 실패`라는 개념이 이에 대한 것이다.

### 3. 호출하는 쪽에서만 오류 복구 가능 여부를 알 때가 많다.

- 함수 내부에서 값을 하드코딩해서 넣었을 경우, 이 값에 의해 발생한 오류는 명백히 **프로그래밍 오류**이다.

  - 👉🏻 이러한 오류는 복구 가능한 오류가 아닐 가능성이 높다.

- 반대로, 인자 값에 인해서 발생한 오류는 복구할 수 있고, **복구해야 하는 오류**이다.

  - 👉🏻 이렇게 `외부 인자`에 의해 발생하는 오류가 **복구 가능한지**는 오직 **해당 함수를 호출하는 코드만**이 알 수 있다.

아래에 해당하는 경우, **`함수에 제공된 값`으로 인해 발생하는 오류**는 **호출하는 쪽**에서 복구하고자 하는 것으로 간주해야 한다.

```
- 함수가 어디서 호출될지, 호출 시 제공되는 값이 어디서 올지 정확한 지식이 없음
- 코드가 미래에 재사용될 가능성이 매우 희박함
```

> ⚠️ 이것의 유일한 예외는, **`코드 계약`을 통해 특정 입력이 무효라는 점이 명백히 드러나는 경우**이다.

즉, **코드 계약을 통해 특정 입력이 무효라는 점이 명백히 드러날 경우**에는 `프로그래밍 오류`라고 가정하고, 이를 `복구할 수 없는 오류`로 간주할 수 있다.

### 4. 호출하는 쪽에서 복구하고자 하는 오류에 대해 인지하도록 하라

복구 가능한 오류인지 아닌지는 대다수가 함수 외부에서 알아차릴 수 있다.

따라서, 코드를 호출하는 측에서는 `함수 호출 과정에서 오류가 발생할 가능성이 있는지` 판단할 수 있어야 한다.

> 👉🏻 즉, 이 함수에서 오류가 발생할 수 있다는 가능성을 호출하는 쪽이 확실히 인지하도록 해야한다.

`4-3`과 `4-5`에서는 **함수에서 오류가 발생할 수 있다는 점**을 함수 호출자에게 어떻게 알릴 수 있을지 알아본다.

## 4-2. 견고성 vs 실패

- `실패` - 더 높은 코드 계층이 오류를 처리하게 하거나 전체 프로그램의 작동을 멈추게 한다.
- `견고성` - 오류를 처리하고 계속 진행한다.

### 1. 신속하게 실패하라

프로그램에서 말하는 실패는 `예외`를 예로 들 수 있을 것이다.  
이러한 실패는 `버그의 실제 발생 지점`과 **가까운 곳에서 발생**해야 한다.

이러한 `신속한 실패`는 아래 두 경우 모두 소프트웨어의 위험 상태를 방지해줄 수 있다.

- 복구 할 수 있는 오류 👉🏻 호출하는 쪽에 오류를 복구할 기회를 제공함
- 복구 할 수 없는 오류 👉🏻 개발자가 문제를 신속하게 파악할 수 있도록 함

또한, 오류를 실제 위치 근처에서 나타내면 `스택 트레이스`를 통해 코드를 일일이 살피는 번거로움도 훨씬 줄일 수 있다.

> 👉🏻 객체 간 소통하는 과정에서, **한 곳에서 발생한 오류**는 다른 객체로 전파될 가능성이 크고, 이에 따라 **여러 계층에 거쳐서** 오류가 발생할 수 있기 때문인 것 같다.

### 2. 요란하게 실패하라

`요란한 실패`는 오류가 발생하는데도 불구하고 아무도 모르는 상황을 막고자 하는 것이다.

- 가장 명백한 방법은 `예외`를 발생시켜 프로그램을 중단시키는 것이다.
- 또 다른 방법은 오류 메시지를 기록하는 것이다. _(로그)_
  - 하지만 이는 **개발자가 로그를 얼마나 자주 확인하는지**에 따라 에러가 무시될 수도 있다.

이처럼 요란하게 실패할 경우, **개발 도중이나 테스트하는 동안**에 버그가 발견될 가능성이 높아진다.

### 3. 오류를 기록하라

일반적으로 소프트웨어를 **견고하게 작성하는 것**이 좋다.  
하지만 이는 `요란한 실패`와는 상반되기도 한다.

이에 대한 해결책은 **프로그래밍 오류가 발견**되면, 개발자가 이를 알아차릴 수 있도록 `프로그래밍 오류를 기록`하고 `모니터링`하는 것이다.

> 이와 같은 예시로 오류 발생 빈도를 모니터링하고, 발생 빈도가 너무 높아지면 개발팀에 알림 메시지를 전송하는 것이 있다.

#### ⚠️ 모든 유형의 오류를 기록하는 것은 주의한다.

하지만 더 높은 계층으로 신호를 보내는 대신, 모든 유형의 오류를 기록하는 것은 극도로 주의해야 한다.

기록만 하면 오류가 숨겨져 문제가 발생할 수 있기 때문이다.

### 4. 오류를 숨기지 않음

아래 항목들을 통해서 오류가 발생했다는 사실을 숨길 수 있지만, `오류 처리`에 있어서는 모두 바람직하지 않다.  
오류가 발생하면 알리는 것이 좋으며, 다음 절에서는 **이 작업을 수행하는 방법**에 대해 설명한다.

#### 기본 값 반환

실제 값이 기본 값인 것인지, 오류가 발생한 것인지 구별할 수 없다.

> 👉🏻 앞서 **코드 계약 챕터**에서 `정신 모델에 기반하여 리턴 값이 모호하게 설정되서는 안된다`는 리뷰 내용과 시사하는 바가 비슷하다.

#### 널 값 반환

널 객체는 **의미 없는 기본 값**을 반환한다. 이 경우에도 결국 위와 같이 `리턴 값의 의미가 모호해지는 문제`가 발생한다.

> 👉🏻 널 객체의 리턴은 **`오류 처리`에 사용하는 것에 바람직하지 않다.**  
> 생각해보니 우테코 프리코스 때 오류 처리 과정에서 널 객체를 리턴했던 적이 있던 것 같다 ...

#### 아무것도 하지 않음

마찬가지로 오류가 발생했음을 외부에 알리지 않으므로, 오류 처리에 적합하지 않다.

## 4-3. 오류 전달 방법

### 명시적 방법

코드를 직접 호출한 쪽에서 오류가 발생할 수 있음을 인지할 수 밖에 없도록 한다.

- 검사 예외
- 널 반환 유형 _(널 안정성의 경우)_
- 옵셔널 반환 유형
- 아웃컴 반환 유형 _(반환값 확인이 필수인 경우)_
- 스위프트 오류

### 암시적 방법

코드를 호출하는 쪽에 오류를 알리지만, 호출하는 쪽에서 그 오류를 신경 쓰지 않아도 된다. 여기서 오류 발생 가능성을 파악하기 위해서는 문서, 코드를 읽는 등의 적극적인 노력이 필요하다.

- 비검사 예외
- 매직값 반환 _(피해야 한다)_
- 프로미스 또는 퓨처
- 어서션
- 체크 _(구현에 따라 달라짐)_
- 패닉

### 1. 요약: 예외

자바는 `검사 예외`와 `비검사 예외`의 개념을 모두 가지고 있다.

### 2. 명시적 방법: 검사 예외

컴파일러는 `검사 예외`에 대해 **호출하는 쪽에서 예외를 인지하도록 강제적으로 조치**한다.  
즉, 호출하는 쪽에서 **예외 처리를 위한 코드를 작성**하거나, 자신의 **함수 시그니처에 해당 예외 발생을 선언**해야 한다.

#### 검사 예외 선언

```java
class NegativeNumberException extends Exception {
    private final Double erroneousNumber;

    NegativeNumberException(Double errorneousNumber) {
        this.erroneousNumber = errorneousNumber;
    }
}

// 함수 시그니처에 예외 발생 선언
Double getSquareRoot(Double value) throws NegativeNumberException {
    if (value < 0.0) {
        throw new NegativeNumberException(value);
    }
    return Math.sqrt(value);
}
```

#### 검사 예외 처리

해당 함수를 호출하는 코드는 명시된 예외를 처리하거나 함수 시그니처에 이 예외를 발생시킬 수 있음을 표시해야 한다.

- 검사 예외 포착

```java
void displaySquareRoot() {
    Double value = ui.getInputNumber();
    try {
        ui.setOutput("Square root is: " + getSqaureRoot(value));
    } catch (NegativeNumberException e) { // 예외 처리ㄴ
        ui.setError("..." + e.getErroneousNumber());
    }
}
```

- 검사 예외 미포착

```java
void displaySquareRoot() throws NegativeNumberException {
    Double value = ui.getInputNumber();
    ui.setOutput("Square root is: " + getSqaureRoot(value));
}
```

### 3. 암시적 방법: 비검사 예외

비검사 예외를 사용하면 다른 개발자들은 코드가 예외를 발생시킬 수 있다는 사실을 전혀 모를 수 있다.

자바에서는 `RuntimeException`이 비검사 예외에 해당한다.

#### 비검사 예외 발생

```java
class NegativeNumberException extends RuntimeException {
    private final Double erroneousNumber;

    NegativeNumberException(Double errorneousNumber) {
        this.erroneousNumber = errorneousNumber;
    }
}

/**
 * @throws NegativeNumberException 값이 음수일 경우
*/
Double getSquareRoot(Double value) {
    if (value < 0.0) {
        throw new NegativeNumberException(value);
    }
    return Math.sqrt(value);
}
```

이처럼 오류에 대해 `비검사 예외`를 발생시키는 경우, 위의 주석처럼 `문서화` 하는 것이 권장된다.

#### 비검사 예외 처리

- 비검사 예외 처리

```java
void displaySquareRoot() {
    Double value = ui.getInputNumber();
    try {
        ui.setOutput("Square root is: " + getSqaureRoot(value));
    } catch (NegativeNumberException e) { // 예외 처리ㄴ
        ui.setError("..." + e.getErroneousNumber());
    }
}
```

- 비검사 예외 미처리

```java
void displaySquareRoot() {
    Double value = ui.getInputNumber();
    ui.setOutput("Square root is: " + getSqaureRoot(value));
}
```

위 코드처럼 `비검사 예외`를 발생시키는 함수를 호출하는 쪽에서는 **예외가 발생할 수 있다는 사실을 전혀 몰라도 된다.**

### 4. 명시적 방법: 널 값이 가능한 반환 유형

널 값은 **특정 값을 계산하거나 얻는 것이 불가능함**을 나타내는 효과적인 방법이 될 수 있다.

> 👉🏻 따라서, 호출하는 쪽에서는 이를 강제적으로 인지하고 그에 따라 처리할 수 밖에 없다. _(명시적 방법)_

다만, 널 값을 반환할 때는 **오류가 발생한 이유에 대한 정보**를 제공하지 않기 때문에, 널 값이 의미하는 바를 `주석문`이나 `문서`에 명시해야 한다.

### 5. 명시적 방법: 아웃컴 반환 유형

실행 도중에 오류 없이 정상적으로 실행되었는지 여부를 `리턴 값`으로 알려주는 방식이다.

하지만 이 방식에도 우려되는 점이 있는데, 바로 호출하는 부분에서 이 리턴 값을 무시하는 경우이다.  
👉🏻 호출하는 부분에서 함수의 **반환 값을 무시**하면 **컴파일러가 경고**를 생성하도록 할 수 있다.

- 자바에서는 `CheckReturnValue` 어노테이션을 활용할 수 있다.

```java
@CheckReturnValue
Boolean sendMessage(Channel channel, String message) {
    if (channel.isOpen()) {
        channel.send(message);
        return true;
    }
    return false;
}
```

- 컴파일러 경고 발생

```java
void sayHello(Channel channel) {
    sendMessage(channel, "hello");
    ui.setOutput("Hello sent");
}
```

- 컴파일러 경고 미발생

```java
void sayHello(Channel channel) {
    if (sendMessage(channel, "hello")) {
        ui.setOutput("Hello sent");
    } else {
        ui.setError("Unable to send hello");
    }
}
```

### 6. 암시적 방법: 프로미스 또는 퓨처

비동기 작업 처리 과정에서 발생한 오류를 처리할 때, `catch` 메서드를 호출해야 한다.  
하지만 호출하는 측에서는 오류 발생 여부를 `세부 사항`을 통해 직접 파악해야 하기 때문에, 이는 **암시적 방법**으로 볼 수 있다.

### 7. 암시적 방법: 매직값 반환

> `매직 값`은 함수의 **정상적인 반환 타입**이지만, 값 자체에 **특별한 의미가 담긴 값**이다.

함수를 호출하는 쪽에서는 매직 값이 무엇인지 `문서`나 `코드`를 직접 확인해야 하기 때문에, **암시적인 방법**으로 볼 수 있다.

👉🏻 매직 값은 오류를 알리는 데 좋은 방법이 아니다.

## 4-4. 복구할 수 없는 오류의 전달

`복구할 수 없는 오류`는 **신속하게 실패**하고 **요란하게 실패**하는 것이 최선의 방법이다.

1. 비검사 예외 발생  
   _복구할 수 없는 오류 👉🏻 개발자가 직접 처리해야 하므로 **실패를 최대한 빨리 알려야** 함. 비검사 예외는 에러 핸들링을 없앨 수 있음_
2. 프로그램이 패닉이 되도록
3. 체크나 어서션의 사용

**오류를 복구할 방법이 없을 때**는 자신을 호출한 쪽에 `오류를 전달하는 것` 외에는 할 수 있는 방법이 없다.

## 4-5. 호출하는 쪽에서 복구하기를 원할 수도 있는 오류의 전달

호출하는 쪽에서 복구를 원할 수도 있는 오류를 함수가 전달하고자 할 때, 이를 어떻게 처리할지에 대한 의견은 매우 분분하다.

1. 비검사 예외
2. 명시적 오류 전달 기법

둘 중 완벽한 정답은 없지만, **팀에서 동의한 철학이 1순위가 되어야 한다**는 것이다.

- 한 쪽의 의견을 따른다면 팀 전체가 해당 의견에 따라야 한다.
- 절반은 `비검사 예외`를, 나머지 절반은 `명시적 오류 전달 기법`을 사용한다면, 코드가 서로 상호작용할 때 악몽같은 상황이 발생할 수 있다.

### 1. 비검사 예외를 사용해야 한다.

#### 코드 구조 개선

**대부분의 오류 처리**가 `코드의 상위 계층`에서 이루어질 수 있기 때문에 **`비검사 예외`를 발생시키면 코드 구조를 개선할 수 있다**고 주장하는 개발자들이 있다.

- 오류가 높은 계층까지 거슬러 올라가며 전달되고, 그 사이에 있는 코드는 오류를 처리할 필요가 없기 때문이다.

> 👉🏻 이 방식의 핵심 장점은 `오류를 처리하는 로직`이 코드 전체에 퍼지지 않고, **별도로 몇 개의 계층에만 있다는 점**이다.

#### 개발자들이 무엇을 할 것인지에 대해서 실용적이어야 함

일부에서는 개발자들이 **너무 많은 명시적 오류 전달을 접하**면, 결국 잘못된 일을 한다고 주장한다.

이를 설명하는 예시는 아래와 같다.

> 기존에 오류가 존재하지 않던 코드를 변경하는 과정에서 새로운 오류가 발생했을 때, 개발 피로도가 증가하여 잘못된 일을 하는 경우이다.

- 오류가 없는 초기 코드

```java
class TemperatureLogger {
    private final Thermometer thermometer;
    private final DataLogger dataLogger;

    void logCurrentTemperature() {
        dataLogger.logDataPoint(
            Instant.now(),
            thermometer.getTemperature()
        );
    }
}

class DataLogger {
    private final InMemoryDataStore dataStore;

    void logDataPoint(Instant time, Double value) {
        dataStore.store(new DataPoint(time.toMillis(), value));
    }
}
```

메모리 대신 디스크를 사용해야 하는 경우, `InMemoryDataStore` 클래스를 `DiskDataStore` 클래스로 교환한다.

> 이때, 기존에는 존재하지 않았던 `IOException`이 발생했다.
> 이를 함수 시그니처에 이를 명시한다면, 모든 상위 계층의 코드를 수정해야 할지도 모른다.

위와 같은 개발 피로도를 피하기 위해 개발자들은 아래와 같은 실수를 저지르기 쉽다는 것이다.

- 오류가 발생하는 코드 - 검사 예외 숨기기

```java
class DataLogger {
    private final DiskDataStore dataStore;

    void logDataPoint(Instant time, Double value) {
        try {
            dataStore.store(new DataPoint(time.toMillis(), value));
        } catch (IOException e) {}
    }
}
```

이처럼 오류를 숨기는 것은 좋은 방법이 아니다.

### 2. 명시적 기법을 사용해야 한다.

> 필자의 주장

#### 매끄러운 오류 처리

`비검사 예외`를 사용하여 **예외가 더 높은 수준으로 전달되도록** 내버려 둔다면, 이는 `사용자 친화적이지 않은 오류 메시지`를 UI에 표시할 수도 있다.

하지만 `명시적 예외`를 발생시켜서 **호출하는 쪽에 잠재적 오류를 강제적으로 인식하도록** 하면, 이러한 오류를 좀 더 매끄럽게 처리할 가능성이 커진다.

#### 실수로 오류를 무시할 수 없다

`반환 타입`이나 `검사 예외`와 같은 방식에서도 앞선 주장처럼 개발자가 실수할 수도 있지만, 암시적 기법보다는 이러한 결함을 더 알아채기 쉬워진다.

#### 개발자들이 무엇을 할 것인지에 대해서 실용적이어야 함

`비검사 예외`의 경우 문서화가 중요할 수 밖에 없는데, **실제로는 문서화가 되지 않는 경우가 많다.**

이는 종종 **어느 코드가 어떤 예외를 발생시킬 것인지 확실하게 알지 못 한다**는 것을 의미하고, 이로 인해 예외를 처리하는 것이 두더지 잡기 게임이 될 수 있다.

### 어떤 주장이더라도, `코드 검토 프로세스`가 가장 중요하다.

어느 주장을 따르더라도, 결국에는 `코드 검토 프로세스`가 가장 중요하다.

> 만약 `코드 검토 프로세스`가 이와 같은 위반을 탐지할 만큼 충분히 강력하지 않다면, **어느 경우라도 문제가 있을 수 있다는 것**을 인지해야 한다.

## 4-6. 컴파일러 경고를 무시하지 말라

컴파일러 경고문이 `복구할 수 없는 오류`를 암시적으로 보여주는 경우가 많다.

따라서 `컴파일러 경고문`을 무작정 넘어가기 보다는, **경고가 발생하는 원인을 짚고 넘어가는 것**이 좋다.
