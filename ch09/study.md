# Chapter 09: 코드를 재사용하고 일반화할 수 있도록 하라

향후에 재사용이 가능하도록 의도적으로 코드를 작성하고 구조화하는 것이 바람직하다.

# 9.1 가정을 주의하라

## 9.1.1 가정은 코드 재사용 시 버그를 초래할 수 있다

특정 조건에 한해서 코드가 동작한다는 가정 하에 작성하면, 상위 계층에서 이를 사용할 때 예기치 못한 버그가 발생할 수 있다.

## 9.1.2 해결책: 불필요한 가정을 피하라

가정으로 인해 얻는 이득이 미미하다면, 오히려 비용이 이점보다 훨씬 클 수 있다.

## 9.1.3 해결책: 가정이 필요하면 강제적으로 하라

1. **가정이 '깨지지 않게' 만들라**  
   가정이 깨지면 컴파일되지 않는 방식으로 코드를 작성할 수 있다면, 가정이 항상 유지될 수 있다. _(3장, 7장)_
2. **오류 전달 기술을 사용하라**  
   가정이 깨졌을 경우, 오류 신호 전달 기술을 사용하여 신속하게 실패하도록 코드를 작성할 수 있다. _(3장, 4장)_

### 문제의 소지가 있는, 강제되지 않은 가정

모든 기사는 이미지를 갖는 섹션이 최대 하나만 있다고 가정한 채 코드를 작성하면, 이미지를 갖는 섹션이 여러 개일 경우 문제가 발생할 수 있다.

### 가정의 강제적 확인

일반적으로 실패와 오류는 명확히 드러나는 것이 최선이다.

오류 전달 기법을 사용하여 가정을 강제로 인지하게 함으로써 신속하게 실패하기 위한 코드로 변경할 수 있다.

- 어서션을 통해 가정을 강제로 시행

```
[ 오류 전달 기법 ]

1. 어서션
어서션은 호출하는 쪽에서 오류로부터 복구하기를 원하지 않는 경우에 적합하다.

2. 명시적 오류 전달 기법
호출하는 쪽에서 더 매끄러운 방식으로 오류를 처리하기 원할 경우, 명시적인 오류 전달 기법이 더 적합할 수 있다.
```

# 9.2 전역 상태를 주의하라

## 9.2.1 전역 상태를 갖는 코드는 재사용하기에 안전하지 않을 수 있다.

## 9.2.2 해결책: 공유 상태에 의존성 주입하라

`의존성 주입`은 전역 상태를 사용하는 것보다 더 통제된 방법으로 **서로 다른 클래스 간에 상태를 공유**하는 좋은 방법이다.

`static` 대신 `의존성 주입`을 사용하면 서로 다른 인스턴스끼리 간섭 없이 독립적으로 값을 변경할 수 있다.

> 👉🏻 프로그램의 서로 다른 부분 간에 **상태를 공유**해야할 경우, `의존성 주입`을 사용해서 보다 통제된 방식으로 수행하는 것이 더 안전하다.

# 9.3 기본 반환값을 적절하게 사용하라

제공되지 않는 매개변수에 대해서는 클래스가 기본 값을 제공할 수 있다.

이때, **낮은 층위**에서는 모든 용도에 적합한 **기본 값을 선택하기가 훨씬 더 어렵다.**

## 9.3.1 낮은 층위의 코드의 기본 반환값은 재사용성을 해칠 수 있다

가정은 상위 계층에 영향을 미친다.

```java
class UserDocumentSettings {
    private final Font font;
    // ...

    public Font getPreferredFont() {
        if (font != null) {
            return font;
        }
        return Font.ARIAL; // 사용자가 선호하는 폰트가 지정되지 않은 경우 기본 값 반환
    }
}
```

위 코드에는 사용자가 **Arial 폰트를 선택한 것**인지, **선호하는 폰트를 설정하지 않은 것**인지 구별하기 어렵다.

이 코드의 문제를 해결할 수 있는 핵심 방법은 하위 문제를 분리하는 것이다.

- `사용자 설정을 검색하는 것`과 `응용 프로그램에 적합한 기본 값을 정의하는 것`은 별개의 하위 문제이다.

## 9.3.2 해결책: 상위 수준의 코드에서 기본값을 제공하라

**기본 값에 대한 결정**을 낮은 층위에서 하지 않는 가장 간단한 방법은, **널 값을 반환하는 것**이다.

```java
class UserDocumentSettings {
    private final Font font;
    // ...

    public Font getPreferredFont() {
        return font;
    }
}
```

```java
class DefaultDocumentSettings {
    // ...

    public Font getDefaultFont() {
        return Font.ARIAL;
    }
}
```

이렇게 하위 문제를 분류하면, 구현 세부 정보를 재설정할 수도 있다.

```java
class DocumentSettings {
    private final UserDocumentSettings userSettings;
    private final DefaultDocumentSettings defaultSettings;

    DocumentSettings(
        UserDocumentSettings userSettings,
        DefaultDocumentSettings defaultSettings
    ) {
        this.userSettings = userSettings;
        this.defaultSettings = defaultSettings;
    }

    public Font getFont() {
        Font userFont = userSettings.getPreferredFont();
        if (userFont != null) {
            return userFont;
        }
        return defaultSettings.getFont();
    }
}
```

> 상위 수준의 코드에서 직접 판단하여 기본 값을 처리하고 있다.

기본 값은 코드의 어느 부분에서 사용할지 조심하는 것이 좋다.  
낮은 층위의 코드에서 기본 값을 반환하는 것은 특히 문제가 될 수 있다.

- 단순히 널을 반환하고, 더 높은 층위에서 기본값을 구현하는 것이 나을 수 있다.

# 9.4 함수의 매개변수를 주목하라

함수가 특정 객체 내에 있는 모든 정보를 필요로 하는 경우, 해당 객체의 인스턴스를 매개변수로 받는 것이 타당하다.

하지만, 객체 내의 일부 정보만 필요로 하는 경우에는 해당 방식이 올바르지 않을 수 있다.

## 9.4.1 필요 이상으로 매개변수를 받는 함수는 재사용하기 어려울 수 있다

## 9.4.2 해결책: 함수는 필요한 것만 매개변수로 받도록 하라

# 9.5 제네릭의 사용을 고려하라

제네릭을 통해 참조하는 모든 유형을 구체적으로 명시할 필요 없이 클래스를 작성할 수 있다.

## 9.5.1 특정 유형에 의존하면 일반화를 제한한다

특정 유형에 의존하면, 다른 유형의 동일한 하위 문제를 해결할 수 있을 만큼 일반화되지 않는다.

코드가 일반화되어 거의 동일한 하위 문제를 해결할 수 있다면 훨씬 더 바람직할 것이다.

## 9.5.2 해결책: 제네릭을 사용하라

제네릭을 통해 코드는 보다 더 일반화되고 재사용이 가능하다.
