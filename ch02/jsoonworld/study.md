# 2 추상화 계층

코드를 구성하는 방법은 코드 품질의 기본적인 측면 중 하나이며, 코드를 잘 구성한다는 것은 간결한 추상화 계층`layers of abstraction` 을 만드는 것으로 귀결될 때가 많다. 

## 2.1 널값 및 의사코드 규약

널값은 믿을 수 없을 정도로 유용하면서도 동시에 믿을 수 없을 정도로 문제가 많은 양극단의 역사를 가지고 있다.

널값이 문제의 소지가 많기 때문에 어떤 사람은 사용하지 말아야 한다고 주장하고, 적어도 함수가 널값을 반환하지 않아야 한다고 조언한다. 널값 문제를 피하기 위해서는 이렇게 하는 것이 확실하게 도움이  되지만, 실제 코드를 작성할 때 이 조언대로 하려면 많은 연습이 필요하다.

## 2.2 왜 추상화 계층을 만드는가?

서버에서 메시지를 보낼 때, 다른 개발자가 이미 작성한 하위 문제에 대한 해결책을 재사용할 수 있다. 간결한 추상화 계층은 상위 수준의 문제를 해결하기 위해 몇 가지 개념만 알면 된다는 것을 의미한다.

좀 더 일반적으로 말해서 어떤 문제를 하위 문제로 계속해서 나누어 내려가면서 추상화 계층을 만든다면, 같은 층위 내에서는 쉽게 이해할 수 있는 몇 개의 개념만을 다루기 때문에 개별 코드는 특별히 복잡해 보이지 않을 것이다. 소프트웨어 엔지니어로서 문제를 해결할 대 이것이 목표가 되어야 한다. 비록 문제가 엄청나게 복잡할지라도 하위 문제들을 식별하고 올바른 추상화 계층을 만듦으로써 그 복잡한 문제를 쉽게 다룰 수 있다.

### 2.2.1

깨끗하고 뚜렷한 추상화 계층을 구축하면 코드 품질의 네 가지 핵심 요소를 달성할 수 있다.

- 가독성
- 모듈화
- 재사용성 및 일반화성
- 테스트 용이성

## 2.3 코드의 계층

- 함수
- 클래스
- 인터페이스
- 패키지, 네임스페이스, 모듈

## 2.3.1 API 및 구현 세부 사항

코드를 작성할 때 고려해야 할 측면이 두 가지 있다.

- 코드를 호출할 때 볼 수 있는 내용:
	- 퍼블릭 클래스, 인터페이스 및 함수(메서드)
	- 이름, 입력 매개변수 및 반환 유형이 표현하고자 하는 개념
	- 코드 호출 시 코드를 올바르게 사용하기 위해 알아야 하는 추가 정보(예: 호출 순서)
- 코드를 호출할 때 볼 수 없는 내용: 구현 세부 사항

어떤 코드를 호출하는 쪽에서 그 코드에 대해 알고 있는 사항을 공개 API라고 생각할 수 있다. API로 공개되지 않은 내용은 구현 세부 사항이다.

API는 호출하는 쪽에 공개할 개념만 정의하면 되고 그 이외의 모든 것은 구현 세부 사항이기 때문에 코드를 API의 관점에서 생각하면 추상화 계층을 만드는 데 도움이 된다. 코드의 일부를 작성하거나 수정할 때, (입력 매개변수, 반환 유형,  퍼블릭 함수를 통해) API에 이 수정 사항에 대한 구현 세부 정보가 새어 나간다면 추상화 계층이 명확하게 구분되어 이루어진 것이 아니다.

### 2.3.2 함수

함수가 하는 일을 다음 중 하나로 제한하면 이해하기 쉽고 단순한 문장으로 표현되는 함수를 작성하기 위한 좋은 전략이 될 수 있다.

- 단일 업무 수행
- 잘 명명된 다른 함수를 호출해서 더 복잡한 동작 구성

이 두 가지 사항이 정확하고 과학적인 것은 아니다. '단일 업무'라는 것이 해석하기 나름이고, 다른 함수를 호출해서 더 복잡한 동작을 구성할 때에도 여전히 (if 문이나 for 루프와 같이) 약간의 제어 흐름이 필요하기 때문이다. 일단 함수를 작성했으면 작성된 코드를 문장으로 만들어보면 좋다. 문장을 만들기 어렵거나 너무 어색하면 함수가 너무 길다는 것을 의미하고 더 작은 함수로 나누는 것이 유익할 것이다.

함수를 작게 만들고 수행하는 작업을 명확하게 하면 코드의 가독성과 재사용성이 높아진다. 코드를 마구 작성하다 보면 너무 길어서 읽을 수 없는 함수가 되기 쉽다. 따라서 코드 작성을 일단 마치고 코드 검토를 요청하기 전에 자신이 작성한 코드를 비판적으로 다시 한번 살펴보는 것이 좋다. 함수를 한 문장으로 표현하기 어렵게 구현했다면 로직의 일부를 잘 명명된 헬퍼 함수로 분리하는 것을 고려해봐야 한다.

### 2.3.3 클래스

개발자들은 단일 클래스의 이상적인 크기에 대해 논의하고 다음과 같은 많은 이론과 경험 법칙을 제시한다.

- 줄 수`number of lines` 
- 응집력 `cohesion`:
	이것은 한 클래스 내의 모든 요소들이 얼마나 잘 속해 있는지를 보여주는 척도로, 좋은 클래스는 매우 응집력이 강하다. 어떤 것들이 어떻게 결속되어 있는지 분류할 수 있는 방식이 많이 있다.
		- 순차적 응집력:
			이것은 한 요소의 출력이 다른 요소에 대한 입력으로 필요할 때 발생한다. 실제적인 예는 신선한 커피 한 잔을 만드는 과정일 것이다. 원두를 갈기 전에는 커피를 추출할 수 없다. 원두를 갈아내는 과정의 산출물은 커피를 추출하는 과정에 투입된다. 그러므로 우리는 갈고`grinding` 추출하는 `brewing` 것 사이에 서로 응집력이 있다고 결론지을 수 있다.
		- 기능적 응집력:
			이것은 몇 가지 요소들이 묘여서 하나의 일을 성취하는 데 기여할 때 발생한다. 하나의 일`single task`이 무엇인가에 대한 정의는 매우 주관적일 수 있지만, 실제 생활에서 예를 찾자면 케이크를 만들기 위해 필요한 모든 장비를 부엌의 전용 서랍에 보관하는 것이 될 수 있다. 반죽을 섞을 그릇, 나무 숟가락, 그리고 케이크 통은 케이크를 만들기 위해 모두 필요하며 함께 있어야 한다.
- 관심사의 분리 `separation of concerns` :
	이것은 시스템이 각각 별개의 문제(또는 관심사)를 다루는 개별 구성 요소로 분리되어야 한다고 주장하는 설계 원칙이다. 이것의 실제적인 예는 게임 콘솔이 TV와 동일한 제품으로 묶이지 않고, TV와 분리되는 방식에서 찾아볼 수 있다. 게임기는 게임을 실행하는 것과 관련이 있고, TV는 동영상을 표시하는 것과 관련이 있다. 이렇게 두 가지가 분리되면 상황에 맞게 구성할 수 있다. 작은 아파트에 사는 사람은 게임기를 살 때 작은 TV에 게임기를 꽂고 싶어할 수도 있다. 이렇게 두 가지 항목이 분리되어 있으면 다른 항목을 업그레이드할 필요 없이 한  항목을 업그레이드 할 수 있다.

응집력과 관심사의 분리에 대해 생각할 때는 서로 관련된 여러 가지 사항을 하나의 사항으로 간주하는 것을 어느 수준에서 해야 유용할지 결정해야 한다. 이것은 매우 주관적일 수 있기 때문에 종종 보기보다 까다로울 수 있다.

기존 코드를 수정할 때나 완전히 새로운 코드를 작성할 때 클래스가 너무 커지는 것은 아닌지 주의해야 한다.
'한 클래스는 오직 한 가지 일에만 관심을 가져야 한다' 혹은 '클래스는 응집력이 있어야 한다'와 같은 경험칙은 개발자들이 더 높은 품질의 코드를 작성하기 위해 존재한다. 하지만 우리가 근본적으로 성취하려고 하는 것에 대해서도 신중하게 생각할 필요가 있다.

클래스가 분리되어야 할지 판단하기 위해서는 이 클래스가 어떻게 네 가지 핵심 요소에 반하여 작성되어 있는지 살펴보는 것이 더 나을 수도 있다.

- 코드를 읽을 수 없다.
- 코드가 특별히 모듈화되어 있지 않다.
- 코드를 재사용할 수 없다.
- 코드를 일반화할 수 없다.
- 코드를 제대로 테스트하기 어렵다.

### 2.3.4 인터페이스

계층 사이를 뚜렷이 구분하고 구현 세부 사항이 계층 사이에 유출되지 않도록 하기 위해 사용할 수 있는 한 가지 접근법은 어떤 함수를 외부로 노출할 것인지를 인터페이스를 통해 결정하는 것이다. 그 다음 이 인터페이스에 정의된 대로 클래스가 해당 계층에 대한 코드를 구현한다. 이보다 위에 있는 계층은 인터페이스에 의존할 뿐 로직을 구현하는 구체적인 클래스에 의존하지 않는다.

하나의 추상화 계층에 대해 두 가지 이상의 다른 방식으로 구현을 하거나 향후 다르게 구현할 것으로 예상되는 경우 인터페이스를 정의하는 것이 좋다.

 필자의 개인적인 경험으로 볼 때 모든 클래스에 인터페이스를 붙이는 극단적인 입장의 코드는 종종 통제가 불가능하고, 불필요하게 복잡해지며, 이해와 수정이 어렵다. 인터페이스를 사용할 경우 그 장점이 확실한 상황에서는 인터페이스를 사용하되, 인터페이스만을 위한 인터페이스를 작성해서는 안된다. 그럼 깨끗하고 뚜렷한 추상화 계층을 만드는 데 집중하는 것은 여전히 중요하다. 인터페이스를 정의하지 않더라도 클래스에서 어떤 함수를 퍼블릭으로 노출할지 매우 신중하게 생각해야 하며 구현 세부 사항이 유출되지 않도록 해야 한다. 일반적으로 클래스를 작성하거나 수정할 때마다 나중에 필요한 경우 인터페이스를 붙이는 것이 어려워지지 않도록 코드를 작성해야 한다.

### 2.3.5 층이 너무 얇아질 때

코드를 별개의 계층으로 세분화하면 장점이 많지만 다음과 같은 추가 비용이 발생한다.

- 클래스를 정의하거나 의존성을 새 파일로 임포트하려고 반복적으로 사용하는 코드 `boilerplate code` 로 인해 코드의 양이 늘어난다.
- 로직의 이해를 위해 파일이나 클래스를 따라갈 때 더 많은 노력이 필요하다.
- 인터페이스 뒤에 꼐층을 숨기게 되면 어떤 상황에서 어떤 구현이 사용되는지 파악하는 데 더 많은 노력이 필요하다. 이로 인해 로직을 이해하거나 디버깅하는 것이 더 어려워질 수 있다.

코드를 서로 다른 계층으로 분할해서 얻는 장점과 비교하면 이 비용이 상당히 낮은 것이지만, 분할을 위한 분할은 의미가 없다는 것을 명심해야 한다. 비용이 이익보다 더 큰 시점이 올 수 있으므로 상식에 맞게 적용하는 것이 좋다.

코드 계층의 규모를 올바르게 결정하는 것은 중요하다. 코드베이스에 의미 있는 추상화 계층이 없으면 전혀 관리할 수 없는 코드가 된다. 계층이 있더라도 각 계층이 너무 크면 쪼개져야 할 여러 추상화가 한 계층으로 병합되어 결국은 모듈화되지 않고, 재사용할 수 없으며, 가독성이 낮은 코드가 된다. 반면 계층을 너무 얇게 만들면 단일 계층으로 만들어도 될 것을 둘로 분해한 것이고, 이것은 불필요한 복잡성을 초래할 수 있다. 또한, 인접한 계층들이 원래 되어야 하는 대로 잘 분리되지 않았음을 의미할 수도 있다. 일반적으로 너무 많은 일을 하는 계층은 너무 적은 일을 하는 계층보다 더 문제가 될 수 있다. 따라서 어떤 것이 더 나을지 확실하지 않다면, 너무 많은 계층을 남용하는 결과를 가져오더라도 계층을 여러 개로 나누는 것이 한 계층 안에 모든 코드를 집어넣는 것보다 낫다.

앞서 클래스를 통해 살펴봤던 것처럼 계층이 너무 두꺼운지 여부를 결정해주는 단 하나의 규칙이나 조언은 존재하지 않는다. 왜냐하면 계층을 몇 개로 나눌지는 해결하려고 하는 실제 현실의 문제에 달려 있기 떄문이다. 최선의 조언은 자신이 만든 계층이 코드의 가독성을 높이고, 재사용할 수 있고, 일반화할 수 있으며, 모듈화되고, 테스트를 용이하게 하는지를 스스로 판단하고 신중하게 생각해보는 것이다.

## 2.4 마이크로서비스는 어떤가?

마이크로서비스는 시스템을 분리하여 보다 모듈화할 수 있는 매우 좋은 방법이지만, 서비스를 구현하기 위해 여러 하위 문제를 해결해야 한다는 사실은 바뀌지 않는다. 올바른 추상화 및 코드 계층을 만드는 것은 여전히 중요하다.















