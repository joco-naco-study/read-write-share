# Chapter2: 추상화 계층

코드는 문제를 해결하기 위해 작성한다. 그리고 우리는 하나의 큰 문제를 여러 개의 작은 문제들로 세분화 할 수 있다.  
👉🏻 하지만 이렇게 세분화된 문제들을 **하나의 거대한 함수 / 클래스로 구현**할 것인지, **여러 개의 함수 / 클래스로 분리할 것인지** 고민해볼 필요가 있다.

```markdown
코드를 잘 구성한다는 것은 `간결한 추상화 계층`을 만드는 것으로 귀결될 때가 많다.
```

## intro: 추상화 계층은 왜 만드는가?

> 복잡한 문제를 간결하게 표현할 수 있다.  
> 즉, `간결한 추상화 계층`은 상위 수준의 문제를 해결하기 위해 몇 가지 개념만 알면 된다는 것을 의미한다.

하위 문제들을 식별하고 올바른 추상화 계층을 만들면, 복잡한 문제를 쉽게 다룰 수 있다.

## 1. 추상화 계층 및 코드 품질의 핵심 요소

> 뚜렷한 추상화 계층을 구축하면 코드 품질의 네 가지 핵심 요소를 달성할 수 있다.

- 가독성

- 모듈화

- 재사용성 및 일반화성

- 테스트 용이성

## 2. 코드의 계층

> 함수, 클래스, 인터페이스 등

### 2-1. API 및 구현 세부 사항

> API는 서비스를 사용할 때 알아야 할 것들에 대한 개념을 형식화하고, 구현 세부 사항은 API 뒤에 감춘다.  
> 👉🏻 코드를 API 관점에서 생각하면 추상화 계층을 명확히 만드는데 도움이 된다.

_코드의 일부를 작성 / 수정할 때, API에 이 **수정 사항에 대한 구현 세부 정보**가 새어 나간다면 추상화 계층이 명확히 구분된 것이 아니다._

### 2-2. 함수

> 함수에 포함된 코드가 짧은 문장처럼 읽히는 것이 이상적이다.

필요한 기능을 하나의 함수가 모두 구현하면,

- 함수의 역할이 과중해지고
- 하위 문제들을 어떻게 해결하는지 이해하기도 어려워진다.
- 또한, 하위 문제를 해결하는 코드를 재사용하기 어려워진다.

```markdown
자신이 작성한 코드를 비판적으로 다시 한번 살펴보는 것이 좋다.
**함수를 한 문장으로 표현하기 어렵게** 구현했다면, 로직의 일부를 잘 명명된 `헬퍼 함수로 분리`하는 것을 고려해봐야 한다.
```

### 2-3. 클래스

> **응집력**  
> 한 클래스 내의 모든 요소들이 얼마나 잘 속해 있는지를 보여주는 척도  
> 👉🏻 관련 하위 문제를 해결하는 것 = 원래 문제와 다른 관심사? vs 원래 문제의 일부분?  
>  👉🏻 저품질 코드인지 판별하는 과정에서 응집도를 확인할 수 있음

> **관심사의 분리**  
> 시스템이 각각 별개의 문제를 다루는 개별 구성 요소로 분리되어야 한다고 주장하는 설계 원칙  
> (ex. 게임 콘솔과 TV가 동일한 제품으로 묶이지 않고 서로 분리된 형태)

- 코드 가독성
  - 단일 클래스에 개념이 많을수록 가독성이 저하된다.
- 코드 모듈화
  - 클래스 및 인터페이스의 사용은 코드 모듈화를 위한 좋은 방법 중 하나이다.
  - `다른 클래스와의 상호작용`이 잘 준비된 **몇몇 퍼블릭 함수를 통해서만(= 추상화 및 API)** 이루어 진다면, 하위 문제에 대한 해결책의 구현을 다른 클래스로 교체할 필요가 있을 때 이를 쉽게 할 수 있다.
- 코드 재사용성 및 일반화
  - 두 하위 문제에 대한 해결책을 한 클래스로 묶어 놓으면, 이를 재사용할 기회가 줄어든다. _(= 하위 문제들을 각각 서로 다른 클래스로 분리할 필요성)_
- 테스트 용이성 및 적절한 테스트
  - 로직이 여러 클래스로 나뉘면 각 부분을 테스트하기 쉬워진다.

```
[ 저품질 코드의 증거 ]

- 코드를 읽을 수 없다.
- 코드가 특별히 모듈화되어 있지 않다.
- 코드를 재사용할 수 없다.
- 코드를 일반화할 수 없다.
- 코드를 제대로 테스트하기 어렵다.
```

_👉🏻 하나의 클래스가 너무 많은 역할을 담당하고 있으며, 적절한 추상화 또한 이뤄지지 않았기 때문_

```
[ 저품질 코드 개선 ]

- 각 하위 문제에 대한 해결책을 자체 클래스로 분할하여 개선할 수 있다.
- 분할된 클래스는 의존성 주입으로 연결한다.
```

### 2-4. 인터페이스

> 계층 사이를 뚜렷하게 구분하고, 구현 세부 사항이 계층 사이에 유출되지 않도록 할 수 있다.

👉🏻 추후 기능이 더 **고도화 되거나 수정될 가능성이 높다**면, 이 기능을 인터페이스로 추출하는 것을 고려하자.

```
인터페이스를 정의함으로써, 주어진 하위 문제를 해결하는 구현 클래스를 쉽게 교체할 수 있다. (= 코드가 모듈화된다.)
외부에서 구현체에 의존하는 것이 아닌 인터페이스에 의존하기 때문이다.
```

### 2-5. 너무 얇은 층

> 인터페이스로 분리하는 범위를 적절하게 설정해야 한다.

👉🏻 다른 곳에서 다시 사용될 여지가 없거나, 서로 연관되어 있는 기능을 서로 다른 클래스로 분리한 경우 모두 **인터페이스 계층을 너무 얇게 쪼갠 것**으로 볼 수 있다.

#### < 교재 예시 >

교재에서는 단락을 분리하는 클래스를 예시로 들고 있다.

`ParagraphFinder` 클래스에서 사용되는 **단락 첫 부분 감지 기능** 및 **단락 끝 부분 감지 기능**을 각각 `ParagraphStartOffsetDetector`와 `ParagraphEndOffsetDetector` 클래스로 분리했다고 가정하자.

이 경우 아래의 두 가지 문제점이 존재하며, 이는 **인터페이스 계층이 너무 얇다**는 것을 의미한다.

- 두 클래스가 `ParagraphFinder` 클래스 이외의 다른 클래스에서 사용될 여지가 적다.
- 설령 다른 클래스에서 사용된다고 하더라도, 두 클래스 중에서 하나만 사용될 가능성은 매우 적다. _(= 두 클래스는 밀접하게 연관되어 있다)_

```markdown
만약 계층이 너무 얇다면, **단일 계층으로 만들어도 될 것**을 **여러 계층으로 분리한 것**이 아닌지 점검해볼 수 있다.
```

👉🏻 따라서 위 예시의 경우에는 `OffsetDetector` 인터페이스를 굳이 분리하지 않고, `ParagraphFinder` 클래스 내부 메소드로 처리해도 충분할 것이라 생각한다.

## 📒 내용 정리

- `추상화`는 외부에서 서비스를 이용할 때 필요한 기능을 명시하는 역할을 한다.
  - 즉, 특정 기능을 수행하는 데 필요한 **최소한의 기능들을 정의**하는 것이다.
  - 교재에서 추상화를 `API`에 비유한 것이 이해하기 수월했다.
- 가능하다면 계층을 최대한 분리하는 것이 좋다. 다만, 너무 얇은 계층으로 쪼개진 것은 아닌지 점검해볼 필요가 있다.
