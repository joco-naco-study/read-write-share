# Chapter 2 - 추상화 계층

코드를 잘 구성한다는 것은 간결한 추상화 계층 (layers of abstraction)

## null 값 및 의사코드 규약

많은 프로그래밍 언어에는 값이 없다는 개념으로 null을 사용한다.

사용중인 언어가 null 안정성을 지원하지 않는다면, null값을 사용하는 대신 Optional 타입을 사용하는 것이 좋다.

### null 안정성을 사용하는 예
```java
// 'Element?'에서 '?'는 이 함수의 반환값이 null 값일 수 있음을 나타낸다.
Element? getFifthElement(List<Element> elements) {
    if (elements.size() < 5) {
        return null;
    }
    return elements[4];
}
```

```java
import java.util.Optional;

Optional<Element> getFifthElement(List<Element> elements) {
    if (elements.size() < 5) {
        return Optional.empty();
    }
    return Optional.of(elements[4]);
}
```
- null 안전성을 지원하지 않는 경우 Optional 타입을 사용한다.


## 왜 추상화 계층을 만드는가??


하나의 문제가 있을 때 이 문제와 하위 문제에 대한 해결책이 일련의 층을 형성하고 있다고 생각하자.

최상위 계층에서는 하위 계층이 어떻게 구현되어 있는지 알 필요도 없다.

**간결한 추상화 계층은 상위 수준의 문제를 해결하기 위해 몇 가지 개념만 알면 된다는 것을 의미한다.**

```java
HttpConnection connection = HttpConnection.connect("http://google.com/server");
connection.send("Hello Google");
connection.close();
```
위 코드는 서버에 메시지를 보내야 한다는 상위 수준의 문제만 보여준다.

상위 수준을 해결하기 위한 하위 수준의 문제는 많고 복잡하지만 이를 구체적으로 알지 못해도 사용할 수 있다.


## 추상화 계층 및 코드 품질의 핵심 요소

꺠끗하고 뚜렷한 추상화 계층을 구축하면 코드 품질의 네 가지 핵심 요소를 달성할 수 있다.

1. 가독성
    - 코드베이스에 있는 모든 세부 사항을 이해하는 것은 불가능하다.
    - 하지만 몇 가지 높은 계층의 추상화를 이해하고 사용하기는 쉽다.
    - 따라서 추상화 계층을 이용하면 가독성이 크게 향상된다.

2. 모듈화
    - 추상화 계층이 하위 문제에 대한 해결책을 깔끔하게 나누고 구현 세부 사항이 외부로 노출되지 않도록 보장한다. 
    - 그렇다면 다른 계층이나 코드의 일부에 영향을 미치지 않고 계층 내에서만 구현을 변경하기가 매우 쉬워진다.

3. 재사용성 및 일반화성
    - 하위 문제에 대한 해결책이 간결한 추상화 계층으로 제시되면 해당 하위 문제에 대한 해결책을 재사용하기가 쉬워진다.
    - 문제가 적절하게 추상적인 하위 문제로 세분화된다면, 해결책은 여러 가지 다른 상황에서 유용하게 일반화될 가능성이 크다.

4. 테스트 용이성
    - 하위 문제에 대한 해결책이 견고하고 제대로 작동하는지 확인해야 한다.
    - 코드가 추상화 계층으로 꺠끗하게 분할되면 각 하위 문제에 해단 해결책을 완벽하게 테스트하는 것이 훨씬 쉬워진다.


## 코드의 계층

추상화 계층을 생성하는 방법은 코드를 서로 다른 단위로 분할하여 단위 간의 의존 관계를 보여주는 의존성 그래프를 생성하는 것이다.

**코드의 단위는 다은 단위에 의존하는데 이로 인해 의존성 그래프가 형성된다.**

### 추상화 계층을 생성하기 위한 요소

- 함수
- 클래스
- 인터페이스
- 패키지, 네임스페이스, 모듈


## API 및 구현 세부 사항

API는 서비스를 사용할 때 알아야 할 것들에 대한 개념을 형식화하고, 서비스의 모든 구현 세부 사항은 API 뒤에 감춘다.

- 클래스 이름, 문사, 퍼블릭 메서드 모두 공개 API에 속한다.
- 퍼블릭 함수의 이름, 반환값 유형, 인수, 문서 모두 공개 API에 속한다.
- 프라이빗 함수와 변수는 모두 구현 세부 사항이다.
- 클래스가 의존하는 것은 구현 세부 사항이다.
- 함수가 비록 퍼블릭이라 해도 함수 내의 코드는 구현 세부 사항에 속한다.

**코드의 일부를 작성하거나 수정할 때, API에 이 수정사항에 대한 구현 세부 정보가 새어 나간다면 추상화 계층이 명확하게 구분되어 이루어진 것이 아니다.**


## 함수 

함수에 포함된 코드가 하나의 잘 써진 짧은 문장처럼 읽히면 이상적이다.

단일 함수 내에서 너무 많은 작업을 수행하면 깊이 중첩된 if 문과 같이 코드를 이해하기 어렵게 만드는 문제가 발생할 수 있다.

**이해하기 쉽고 단순한 함수를 작성하기 위한 전략**
1. 단일 업무 수행
2. 잘 명명된 다른 함수를 호출해서 더 복잡한 동작 구성

함수를 작게 만들고 수행하는 작업을 명확하게 하면 코드의 가독성과 재사용성이 높아진다.

함수를 한 문장으로 표현하기 어렵게 구현했다면 로직의 일부를 잘 명명된 헬퍼 함수로 분리하는 것을 고려해봐야 한다.


## 클래스

단일 클래스의 이상적인 크기에 대한 기준

- 줄 수 (number of lines)
    - 300줄 보다 긴 클래스는 너무 많은 개념을 다루므로 분리해야 한다.
    - 다만, 모든 경우에 있어서 위 규칙이 옳다는 것은 아니다.

- 응집력 (cohesion)
    - 좋은 클래스는 응집력이 매우 강하다.
    - **순차적 응집력**
      - 한 요소의 출력이 다른 요소에 대한 입력으로 필요할 때 발생
    - **기능적 응집력**
      - 몇 가지 요소들이 모여서 하나의 일을 성취하는 데 기여할 대 발생    

- 관심사의 분리 (separation of concerns)
    - 시스템이 각각 별개의 문제(또는 관심사)를 다루는 개별 구성 요소로 분리되어야 한다.

응집력과 관심사의 분리에 대해 생각할 때는 서로 관련된 여러 가지 사항을 하나의 사항으로 간주하는 것을 어느 수준에서 해야 유용할지 결정해야 한다.

1. 코드 가독성
   - 단일 클래스에 담겨 있는 개념이 많을수록 해당 클래스의 가독성은 저하된다.
2. 코드 모듈화
   - 하위 문제에 대한 해결책이 하나의 클래스로 구현되어 있고, 다른 클래스와의 상호작용은 잘 준비된 몇가지 퍼블릭 함수를 통해서만 이루어진다면,
   - 그 하위 문제에 대한 해결책의 구현을 다른 클래스로 교체할 필요가 있을 때 이것을 쉽게 할 수 있다.
3. 코드 재사용성 및 일반화
   - 두 하위 문제대 대한 해결책을 한 클래스로 묶어 놓는다.
   - 그렇다면 다른 누군가가 이미 구현된 한 가지 해결책을 재사용할 기회가 줄어든다.
4. 테스트 용이성 및 적절한 테스트
   - 로직이 여러 클래스로 나누어지면 각 부분을 적절하게 테스트하기가 훨씬 쉬워진다.


**코드를 적절한 크기의 클래스로 쪼개지 않으면 너무 많은 개념을 한꺼번에 다루고, 가독성이 떨어지며 모듈화가 덜 이루어지고, 재사용과 일반화가 어렵고, 테스트하기도 어려워진다.**

## 인터페이스

**인터페이스를 통해 어떤 함수를 외부로 노출할 것인지 결정하는 것은 계층 사이를 뚜렷이 구분하고 구현 세부 사항이 계층 사이에 유출되지 않도록 해준다.**

하나의 추상화 계층에 대해 두 가지 이상의 다른 방식으로 구현을 하거나 향후 다르게 구현할 것으로 예상되는 경우 인터페이스를 정의하는 것이 좋다!

추상화 계층을 나타애기 위한 인터페이스를 정의함으로써 주어진 하위 문제를 해결하는 구현 클래스를 쉽게 교체할 수 있다.

따라서 코드가 모듈화되고 설정 가능하다!

**하위 문제에 대해 둘 이상의 서로 다른 구체적인 구현이 가능하고 이들 구현 클래스 사이에 전환이 필요할 때는 인터페이스를 정의하는 것이 가장 좋다.**

> 다만, 주어진 추상화 계층에 대해 한 가지 구현만 있고 향후에 다른 구현을 추가할 계뢱이 없더라도 여전히 인터페이스를 통해 추상화 계층을 표현해야 하는가는 우리 또는 팀이 결정해야 하는 사항이다!

### 한 가지 구현만 있을 때에도 인터페이스를 사용할 때의 이점

1. 퍼블릭 API를 매우 명확하게 보여준다.
- 이 계층에서 사용해야 하는 기능과 사용하지 말아야 하는 기능에 대해 혼동할 일이 없다.
2. 한 가지 구현만 필요하다고 잘못 추측한 것일 수 있다.
3. 테스트를 쉽게 할 수 있다.
4. 같은 클래스로 두 가지 하위 문제를 해결할 수 있다.

### 한 가지 구현만 있을 때에도 인터페이스를 사용할 때의 단점

1. 더 많은 작업이 필요하다.
2. 코드가 복잡해질 수 있다.


## 층이 너무 얇아질 때

### 단점

1. 클래스를 정의하거나 의존성을 새 파일로 임포트하려고 반복적으로 사용하는 코드로 인해 코드의 양이 늘어난다.
2. 로직의 이해를 위해 파일이나 클래스를 따라갈 때 더 많은 노력이 필요하다.
3. 인터페이스 뒤에 계층을 숨기게 되면 어떤 상황에서 어떤 구현이 사용되는지 파악하는 데 더 많은 노력이 필요하다. 이로 인해 로직을 이해하거나 디버깅하는 것이 더 어려워질 수 있다.

다만, 일반적으로 너무 많은 일을 하는 계층은 너무 적은 일을 하는 계층보다 더 문제가 될 수 있다.

따라서 어떤 것이 더 나을지 확실하지 않다면, 너무 많은 계층을 남용하는 결과를 가져오더라도 계층을 여러 개로 나누는 것이 한 계층 안에 모든 코드를 집어넣는 것보다 낫다.


## 마이크로서비스는 어떤가?

마이크로서비스 아키텍쳐에서는 개별 문제에 대한 해결책이 단지 단일 프로그램으로 컴파일되는 라이브러리 수준이 아니라 독립적으로 실행되는 서비스로 배포된다.

즉, 시스템이 여러 개의 소규모 프로그램으로 분할되어 특정 작업만 전문적으로 수행한다.

이런 소규모 프로그램은 API를 통해 원격으로 호출할 수 있는 전용 서비스로 배포된다.

마이크로서비스를 사용할 때 코드 구조를 만들고 코드에 추상화 계층을 만드는 것은 중요하지 않다는 주장을 들을 수도 있다!

마이크로서비스는 일반적으로 꽤 간결한 추상화 계층을 제공하는 것이 사실이지만, 대개 크기와 범위를 기준으로 마이크로서비스를 나누기 때문에 여전히 그 내부에서 적절한 추상화 계층을 고려한느 것이 유용하다.

마이크로서비스는 시스템을 분리하여 보다 모듈화할 수 있는 매우 좋은 방법이지만, 서비스를 구현하기 위해 여러 하위 문제를 해결해야 한다는 사실은 바뀌지 않는다.

올바른 추상화 및 코드 계층을 만드는 것은 여전히 중요하다!!


## 요약

1. 코드를 깨끗하고 뚜렷한 추상화 계층으로 세분화하면 가독성, 모듈화, 재사용, 일반화 및 테스트 용이성이 향상된다.
2. 특정 언어에 국한된 기능뿐만 아니라 함수, 클래스 및 인터페이스를 사용하여 코드를 추상화 계층으로 나눌 수 있다.
3. 코드를 추상화 계층으로 분류하는 방법을 결정하려면 해결 중인 문제에 대한 판단과 지식을 사용해야 한다.
4. 너무 비대한 계층 때문에 발생하느 문제는 너무 얇은 계층 때문에 발생하는 문제보다 더 심각하다. 확실하지 않은 경우에는 남용의 위험에도 불구하고 계층을 얇게 만드는 것이 좋다.


## 소감

추상화 계층을 생성하기 위한 요소 함수, 클래스 , 인터페이스 , 패키지, 네임스페이스, 모듈 등이 존재한다.

이런 다양한 요소들 속에서도 항상 고려해야 하는 것은 코드 품질의 네 가지 핵심 요소라는 것을 알 수 있었다.

코드 가독성, 코드 모듈화, 코드 재사용성 및 일반화, 테스트 용이성 및 적절한 테스트라는 요소들을 지키기 위한 코드를 작성하다 보면 좋은 추상화 계층을 달성 할 수 있을 것이라 생각했다.

다만 모든 상황에서 이런 요소들을 완벽하게 지키기 위해 고분분투 할 필요는 없다고 생각했다.

상황에 맞게 적절히 타협하고 효율성 높은 방법을 채택하는 것이 더 중요할 것이다!