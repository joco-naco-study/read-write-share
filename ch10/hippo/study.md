# Chapter 10. 단위 테스트의 원칙

## 단위 테스트 기초

- 테스트 중인 코드 : '실제 코드' or 테스트의 대상이 되는 코드
- 테스트 코드 : 단위 테스트를 구성하는 코드
- 테스트 케이스 : 테스트 코드의 각 파일에는 일반적으로 여러 테스트 케이스가 있고, 각 테스트 케이스는 특정 동작이나 시나리오를 테스트한다.
  - 준비 (arrange) : 테스트할 특정 동작을 호출하기전 설정하는 과정 (의존성 설정, 인스턴스 생성 등 ..)
  - 실행 (act) : 테스트 중인 동작을 실제로 호출
  - 단언 (assert) : 실제로 올바른 일이 발생했는지 확인
- 테스트 러너 : 실제로 테스트를 실행하는 도구

> 주어진 (given), 때 (when), 그리고 나면 (when)
> 
> 준비, 실행, 단언이라는 용어 대신 사용한다

나쁘거나 부적절하게 테스트된 코드는 언젠가 사고가 날 수밖에 없다!

---

## 좋은 단위 테스트는 어떻게 작성할 수 있는가??

**좋은 단위 테스트가 가져야 할 5가지 주요 기능**

- 훼손의 정확한 감지
  - 코드에 대한 초기 신뢰를 준다
  - 미래의 훼손을 막아준다
  - 테스트 대상 코드가 실제로 훼손된 경우에만 테스트가 실패해야 한다!
    - 플래키 테스트를 짜면 안된다. (flakey test는 무작위성, 타이밍 기반 레이스 조건, 외부 시스템에 의존하는 등 테스트의 비경정적 동작에서 기인한다.)

- 세부 구현 사항에 독립적
  - 개발자가 코드베이스에 가할 수 있는 변경
    - 기능적 변화
      - 코드를 사용하는 모든 사람에게 영향을 미친다.
      - 기능적 변경은 코드의 동작을 수정하기 때문에 테스트도 수정해야 한다.
    - 리팩터링
      - 코드를 사용하는 사람에게 영향을 미치지 않아야 한다.

> 기능 변경과 리팩터링을 같이 하지 말라
> 
> 코드베이스를 변경할 때 일반적으로 기능만 변경하거나 리팩터링만 해야지 두 가지 작업을 동시에 수행하는 것은 좋지 않다.
> 리팩터링은 어떠한 동작도 변경하지 않지만, 기능 변경은 동작을 변경한다.
> 기능적 변화와 리팩터링을 동시에 하면 기능적 변화로 예상되는 동작의 변화와 리팩터링의 실수로 발생하는 동작의 변화를 구분하기 어려울 수 있다.
> 보통 리팩터링을 한 다음 기능 변경을 따로 하는 것이 좋다.
    
- 잘 설명되는 실패
  - 단지 잘못됐다고만 알려주는 테스트보다 무엇이 잘못되었는지 명확하게 설명하는 테스트 실패가 훨씬 더 유용하다.
  - 하나의 테스트 케이스는 한 가지 사항만 검사하고 각 테스트 케이스에 대해 서술적인 이름을 사용하자.

- 이해할 수 있는 테스트 코드

- 쉽고 빠르게 실행
  - 개발자는 코드를 개발하는 동안 단위 테스트를 수없이 많이 실행하기 때문에 느린 단위 테스트는 개발자의 작업 속도를 느리게 만든다.

---

## 퍼블릭 API에 집중하되 중요한 동작은 무시하지 말라

퍼블릭 API에 초점을 맞추면 세부 사항이 아닌 코드 사용자가 궁극적으로 신경 쓸 동작에 집중할 수밖에 없게 된다.

이렇게 하면 실제로 중요한 사항만 테스트 하는 데 도움이 되며, 테스트 과정에서 구현 세부 사항에 상관없이 테스트를 수행할 수 있다.

```java
void testCalculateKineticEnergy_correctValueReturned() {
    assertThat(calculateKineticEnergyJ(3.0, 7.0))
            .isWithin(1.0e-10)
            .of(73.5);
}
// 값이 73.5의 0.0000000001 이내인지 확인한다.
```

### 중요한 동작이 퍼블릭 API 외부에 있을 수 있다.

테스트는 가능하면 퍼블릭 API를 사용하여 테스트하는 것을 목표로 해야 한다.

그러나 설정을 수행하고 원하는 부수 효과를 확인하기 위해 테스트가 공용 API의 일부가 아닌 종속성과 상호작용해야 하는 경우가 많다.

가능하면 퍼블릭 API를 사용하여 코드의 동작을 테스트해야 한다.

이는 순전히 포블릭 함수의 매개변수, 반환값, 오류 전달을 통해 발생하는 동작만 테스트해야 한다는 의미다.

그러나 코드의 퍼블릭 API를 어떻게 정의하느냐에 따라 퍼블릭 API만으로는 모든 동작을 테스트할 수 없는 경우가 있다.

다양한 의존성을 설정하거나 특정 부수 효과가 발생했는지 여부를 확인하는 것이 이에 해당한다.

**예시**

- 서버와 상호작용하는 코드
- 데이터베이스에 값을 저장하거나 읽는 코드

코드의 모든 중요한 동작을 제대로 테스트하는 것이 중요하며, 퍼블릭 API라고 생각하는 것만으로는 이것을 할 수 없는 경우가 있다.

**그러나 테스트를 구현 세부 사항에 최대한 독립적으로 수행하도록 주의를 기울여야 하므로 다른 대안이 없는 경우에만 퍼블릭 API를 벗어나 테스트해야 한다!**

---

## 테스트 더블

의종성을 실제로 사용하는 것에 대한 대안으로 테스트 더블이 있다.

테스트 더블은 의존성을 시뮬레이션하는 객체지만 테스트에 더 적합하게 사용할 수 있도록 만들어진다.

세 가지 유형의 테스트 더블, 목 (mock), 스텁(stub), 페이크(fake)가 있다.


### 테스트 더블을 사용하는 이유

- 테스트 단순화
  - 의존성을 실제로 사용하는 대신 테스트 더블을 사용하면 작업이 단순해진다.
  - 테스트에서 의존성을 실제로 사용할 때 설정이 필요하거나 하위 수준의 의존성에서 무언가 검증을 해야 한다면 통제할 수 없는 상황이 될 수 있다.
  - 이 경우에는 테스트 더블을 사용하는 것이 더 낫다.
  - 테스트 더블은 하위 의존성에 대한 우려를 제거하여 테스트를 단순화할 수 있다.
  - 테스트에서 의존성을 실제로 사용하는 것은 비현실적이다. 의존성이 하위 의존성을 많이 가지고 있고 이 하위 의존성과 상호작용이 필요한 경우가 이에 해당한다.

- 테스트로부터 외부 세계 보호
  - 의존성이 부수 효과를 실제로 일으킨다면, 의존성을 실제로 사용하는 대신 테스트 더블을 사용하는 것이 좋다.
  - 테스트 더블은 외부 세계의 실제 시스템에 대해 부수 효과가 일어나지 않도록 보호할 수 있다.
  
- 외부로부터 테스트 보로
  - 의존성이 비결정적인 방식으로 작용하는 경우 테스트가 신뢰하기 어려워진다.
  - 테스트 더블은 의존성 코드가 실제로 동작할 때 일어날 수 있는 비결정적 동작으로부터 테스트를 보호한다.


### 목 (mock)

목 (mock)은 클래스나 인터페이스를 시뮬레이션하는 데 멤버 함수에 대한 호출을 기록하는 것 외에는 어떠한 일도 수행하지 않는다.

함수가 호출될 때 인수에 제공되는 값을 기록한다.

테스트 대상 코드가 의존성을 통해 제공되는 함수를 호출하는지 검증하기 위해 목을 사용할 수 있다.

따라서 목은 테스트 대상 코드에 부수 효과를 일으키는 의존성을 시뮬레이션하는 데 가장 유용하다.

목을 사용하는 테스트 케이스
```java
void testSettleInvoice_accountDebited() {
    // BankAccount의 목 객체가 생성된다.
    BankAccount mockAccount = createMock(BankAccount);
    
    MonetaryAmount invoiceBalance = new MonetaryAmount(5.0, Currency.USD);
    Invoice invoice = new Invoice(invoiceBalance, "test-id");
    PaymentManager paymentManager = new PaymentManager();
    
    // 테스트 대상 코드는 mockAccount를 인수로 해서 호출된다.
    paymentManager.settleInvoice(mockAccount, invoice);
    
    // mockAccount.debit() 함수가 예상한 인수로 호출되는지 확인한다.
    verifyThat(mockAccount,debit)
            .wasCalledOnce()
            .withArguments(invoiceBalance);
}
```

---

## 스텁 (stub)

스텁은 함수가 호출되면 미리 정해 놓은 값을 반환함으로써 함수를 시뮬레이션한다.

이를 통해 테스트 대상 코드는 특정 멤버 함수를 호출하고 특정 값을 반환하도록 의존성을 시뮬레이션할 수 있다.

그러므로 스텁은 테스트 대상 코드가 의존하는 코드로부터 어떤 값을 받아야 하는 경우 그 의존성을 시뮬레이션하는 데 유용하다.

getBalance()를 호출하는 코드
```java
class PaymentManager {
    // ...
    
    PaymentResult settleInvoice(
            BankAcount customerBankAccount, Invoice invoice) {
        if (customerBankAccount.getBalance()
                .isLessThan(invoice.getBalance())) {
            return PaymentResult.insufficientFunds(invoice.getId());
        }
        customerBankAccount.debit(invoice.getBalace());
        return PaymentResult.paid(invoice.getId());
    }
}
```

스텁을 사용하는 테스트 케이스
```java
void testSettleInvoice_insufficientFundsCorrectResultReturned() {
    MonetaryAmount invoiceBalance = new MonetaryAmount(10.0, Currency.USD);
    Invoice invoice = new Invoice(invoiceBalance, "test-id");
    
    // 스텁만 필요하지만 BankAccount 인터페이스에 대한 목 객체를 생성한다.
    BankAccount mockAccount = createMock(BankAccount);
    
    // mockAccount.getBalance() 함수는 스텁을 통해 항상 9.99달러를 반환하도록 설정된다.
    when(mockAccount.getBalance()).thenReturn(new MonetaryAmount(9.99, Currency.USD));
    PaymentManager paymentManager = new PaymentManager();

    PaymentResult result = paymentManager.settleInvoice(mockAccount, invoice);

    // '잔액 부족'이라는 결과가 반환되는지 확인한다.
    assertThat(result.getStatus()).isEqualsTo(INSUFFICIENT_FUNDS);
}
```

### 목과 스텁은 문제가 될 수 있다

- 목과 스텁은 실제적이지 않은 테스트를 만들 수 있다.
  - 목이나 스텁이 실제 의존성과 다른 방식으로 동작하도록 설정되면 테스트는 실제적이지 않다.
  - 실제 의존성이 어떻게 동작하는지 이해하지 못하면 목을 설정할 때 실수를 할 가능성이 크다.

- 목과 스텁을 사용하면 테스트가 구현 세부 정보에 유착될 수 있다.
  - 구현 세부 사항과 테스트가 밀접하게 결합하여 리팩터링이 어려워질 수 있다.


---

## 페이크 (fake)

페이크는 실제 의존성의 공개 API를 정확하게 시뮬레이션하지만 구현은 일반적으로 단순한데, 외부 시스템과 통신하는 대신 페이크 내의 멤버 변수에 상태를 저장한다.

- 페이크로 인해 보다 실질적인 테스트가 이루어질 수 있다.

- 페이크를 사용하면 구현 세부 정보로부터 테스트를 분리할 수 있다.

---

## 요약

- 코드베이스에 제출된 거의 모든 '살제 코드'는 그에 해당하는 단위 테스트가 동반되어야 한다.
- '실제 코드'가 보여주는 모든 동작에 대해 이를 실행해보고 결과를 확인하는 테스트 케이스가 작성되어야 한다. 아주 간단한 테스트 케시으사 아니라면 각 테스트 케이스 코드는 준비, 실행 및 단언의 세 가지 부분을 나누는 것이 일반적이다.
- 바람직한 단위 테스트의 주요 특징은 다음과 같다.
  - 문제가 생긴 코드의 정확한 탐지
  - 구현 세부 정보에 구애받지 않음
  - 실패가 잘 설명됨
  - 이해하기 쉬운 테스트 코드
  - 쉽고 빠르게 실행
- 테스트 더블은 의존성을 실제로 사용하는 것이 불가능하거나 현실적으로 어려울 때 단위 테스트에 사용할 수 있다. 테스트 더블의 몇 가지 예는 다음과 같다.
  - 목
  - 스텁
  - 페이크
- 목 및 스텁을 사용한 테스트 코드는 비현실식이고 구현 세부 정보에 밀접하게 연결될 수 있다.
- 목과 스텁의 사용에 대한 여러 의견이 있다. 필자의 의견은 가능한 한 실제 의존성이 테스트에 사용되어야 한다는 것이다.
- 이렇게 할 수 없다면, 페이크가 차선책이고, 목과 스텁은 최수의 수단으로만 사용되어야 한다.