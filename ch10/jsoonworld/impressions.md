코드베이스에 제출되는 거의 모든 "실제 코드"는 반드시 단위 테스트와 함께해야 한다는 원칙이 특히 와닿았다. 테스트가 단순히 형식적으로 존재하는 것이 아니라, 실제 코드가 수행하는 모든 동작을 직접 실행하고 그 결과를 검증하는 방식이어야 한다는 점이 중요하게 느껴졌다. 이를 통해 코드가 원하는 대로 동작하는지 확신할 수 있고, 코드 변경 시 발생할 수 있는 문제도 빠르게 감지할 수 있기 때문이다.

테스트 코드 작성 시 **준비(Arrange), 실행(Act), 단언(Assert)** 세 가지 부분으로 나누는 것이 일반적이라는 내용도 인상적이었다. 처음에는 단순한 테스트라면 굳이 이 구조를 엄격하게 따를 필요가 있을까 싶었지만, 명확한 구분이 있으면 테스트의 목적이 분명해지고 가독성도 향상될 것이라는 점에서 필요성을 느꼈다.

또한, 바람직한 단위 테스트의 특징으로 **문제의 정확한 탐지, 구현 세부 사항과의 분리, 실패 시 명확한 설명, 이해하기 쉬운 코드, 빠르고 쉽게 실행 가능**한 점이 언급된 것이 기억에 남았다. 특히 테스트가 **구현 세부 사항에 구애받지 않아야 한다**는 점이 중요하다고 생각했다. 테스트가 내부 구현에 의존하게 되면, 코드 리팩토링 시 테스트도 함께 변경해야 하는 부담이 생기기 때문에 이상적인 테스트는 동작 자체를 검증해야 한다는 점이 와닿았다.

테스트 더블(Mock, Stub, Fake)에 대한 부분도 흥미로웠다. 특히 목(Mock)과 스텁(Stub)을 사용한 테스트가 비현실적이거나 구현에 밀접하게 결합될 수 있다는 점이 새롭게 다가왔다. 필자는 가능한 실제 의존성을 테스트에서 사용하는 것이 가장 바람직하며, 불가능한 경우 차선책으로 **페이크(Fake)** 를 사용하고, **목(Mock)과 스텁(Stub)은 최후의 수단으로만 사용해야 한다**고 강조했다. 이 부분이 기존에 가졌던 인식과 조금 달라서 인상 깊었다. 테스트를 작성할 때 무조건 목(Mock)을 사용하는 것이 아니라, 가능한 한 실제 의존성을 활용하는 것이 더 자연스럽고 의미 있는 테스트를 만들 수 있다는 점을 다시 한번 생각하게 되었다.

이러한 내용들을 통해 단순히 "테스트가 있다"는 것보다 "좋은 테스트가 무엇인가?"에 대한 고민이 더 깊어졌다. 앞으로 테스트를 작성할 때 단순한 코드 검증을 넘어, **변경에 강하고 직관적인 테스트**를 만드는 것에 더 신경 써야겠다고 느꼈다.
