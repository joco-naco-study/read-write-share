# Chapter 10: 단위 테스트의 원칙

**단위 테스트**는 상대적으로 **격리된** 방식으로 **코드의 구별되는 단위를 테스트**하는 것에 관한 것이다.

중요한 것은 코드를 잘 테스트하고 이 작업을 유지보수할 수 있는 방법으로 수행하는 점이다.

- 이를 달성하는 데 도움이 되는 단위 테스트의 몇 가지 핵심 원칙을 다룬다.

---

# 10.1 단위 테스트 기초

- 테스트 중인 코드 _(= 실제 코드)_
  - 테스트의 대상이 되는 코드를 의미함
- 테스트 코드
  - 단위 테스트를 구성하는 코드
- 테스트 케이스
  - 특정 동작이나 시나리오를 테스트하는 코드
  - 일반적으로 arrange(= given), act(= when), assert(= then)의 세 가지 섹션으로 나뉘어져 있다.
- 테스트 러너
  - 테스트를 실행하는 도구

---

# 10.2 좋은 단위 테스트는 어떻게 작성할 수 있는가?

좋은 단위 테스트가 가져야 할 5가지 주요 기능은 다음과 같다.

1. 훼손의 정확한 감지
2. 세부 구현 사항에 독립적
3. 잘 설명되는 실패
4. 이해할 수 있는 테스트 코드
5. 쉽고 빠르게 실행

## 10.2.1 훼손의 정확한 감지

단위 테스트의 주된 목표는 코드가 훼손되지 않았는지 확인하는 것이다.  
즉, 코드가 의도된 대로 수행하며 버그가 없다는 것을 확인하는 것이다.

- 코드에 대한 초기 신뢰를 준다
- 미래의 훼손을 막아준다
  - 어떤 것이 고장났을 때, 코드가 컴파일을 멈추도록 하는 것은 불가능하므로, `모든 올바른 동작`을 **테스트를 통해 확인하는 것**이 매우 중요하다.

정확성의 또 다른 측면을 고려하는 것도 중요하다.  
테스트 **대상 코드가 실제로 훼손된 경우에'만'** 테스트가 실패해야 한다.

- ex) 때로는 통과하고 때로는 실패하는 테스트 _(날짜, 시간에 의존 ...)_

**무작위성**, **타이밍 기반 경쟁 조건**, **외부 시스템에 의존**하는 등의 `외부적인 요인`에 의해 동작하는 경우, 테스트의 정확성은 떨어질 수 있다.

## 10.2.2 세부 구현 사항에 독립적

코드베이스에 가할 수 있는 변경은 두 가지 종류가 있다.

1. 기능적 변화  
   코드가 외부로 보이는 동작을 수정 _(ex. 새로운 기능 추가, 버그 수정, 에러 처리 등)_
   - 이러한 변경을 가하기 전에는 코드를 호출하는 쪽을 신중히 고려해야 함
2. 리팩터링  
   코드의 구조적 변화
   - 코드를 사용하는 사람에게 영향을 미치지 않아야 함

만약에 테스트 코드가 **코드의 모든 동작을 확인**할 뿐만 아니라, **다양한 구현 세부 사항도 확인**할 수 있다면 어떨까? 예를 들면 아래와 같다.

- **프라이빗 함수**를 테스트 코드에서 접근할 수 있도록 하는 것
- **프라이빗 멤버 변수** 및 **의존성**을 직접 조작하여 상태를 시뮬레이션 하는 것
- 코드가 실행된 후 다양한 **멤버 변수의 상태**를 검증하는 것

이러한 테스트 코드는 **_리팩터링에 매우 취약_** 하다.  
리팩터링이 진행되는 순간 테스트 코드는 실패할 것이므로, 리팩터링과 동시에 테스트 코드를 함께 수정해야 하기 때문이다.

- 👉🏻 이는 **리팩터링이 정상적으로 진행되었는지**를 확신하기 어렵게 만들기도 한다.

```
[ 기능 변경과 리팩터링을 같이 하지 말 것 ]

코드베이스를 변경할 때, 일반적으로 기능만 변경하거나 리팩터링만 해야지 두 가지 작업을 동시에 수행하는 것은 좋지 않다.
```

테스트가 구현 세부 정보에 의존하지 않으면, 코드 리팩터링에 실수가 있었는지 확인해주는 테스트 결과를 신뢰할 수 있다.

## 10.2.3 잘 설명되는 실패

테스트 케이스가 어떤 동작에 대한 것인지 이름으로 명확히 드러내는 것이 좋다.

**테스트 실패가 잘 설명되도록 하는 좋은 방법**은 다음과 같다.

1. 하나의 테스트 케이스는 **한 가지 사항만 검사**한다.
2. 각 테스트 케이스에 대해 **서술적인 이름**을 사용한다.

## 10.2.4 이해 가능한 테스트 코드

문제가 발생할 수 있는 가장 일반적인 경우는 다음과 같다.

1. 한번에 너무 많은 것을 테스트 하는 것
2. 너무 많은 공유 테스트 설정을 사용하는 것

이 두 가지 모두 이해하기 어렵고 추론하기 어려운 테스트로 이어질 수 있다.

## 10.2.5 쉽고 빠른 실행

많은 경우에 코드 베이스 병합 전에 테스트를 실행하고, 모든 테스트가 통과 되는지 검사한다.

빠른 작업 실행을 위해서라도 테스트 코드는 빠르게 실행되는 것이 좋다.

- 👉🏻 데이터베이스 서버에 직접 연결하는 등, **외부 요인에 의존하게 되면 그만큼 실행 시간도 느려질 것**

---

# 10.3 퍼블릭 API에 집중하되 중요한 동작은 무시하지 말라

**_'퍼블릭 API만을 사용한 테스트'_** 는 단위 테스트와 관련해 매우 일반적인 조언이다.

- 실제 **중요한 사항만 테스트**하는 데 도움이 되며, 테스트 과정에서 **구현 세부 사항에 상관없이** 테스트를 수행할 수 있기 때문

## 10.3.1 중요한 동작이 퍼블릭 API 외부에 있을 수 있다

테스트 대상 코드는 수많은 다른 코드에 의존하는 경우가 많다.

그리고 테스트에 관해서, 퍼블릭 API로 제공되지 않는 것 중에서도 **테스트 코드가 알아야 할 다른 사항들이 있을 수** 있다. _(ex. 의존성, 부수효과 ...)_

- 👉🏻 의존성을 갖는 다른 객체에 부수효과를 일으키는 동작이 핵심 동작에 포함되는 경우, 이 또한 테스트에 포함해야 한다.

이처럼 퍼블릭 API만으로는 핵심 기능을 모두 테스트하지 못하는 경우가 존재한다.

- 서버와 상호작용하는 코드
- 데이터베이스에 값을 저장하거나 읽는 코드

테스트를 구현 세부 사항에 최대한 독립적으로 수행하도록 주의를 기울여야 하므로, **다른 대안이 없는 경우에만 퍼블릭 API를 벗어나 테스트**를 해야 한다.

---

# 10.4 테스트 더블

> **테스트 더블**  
> 의존성을 실제로 사용하는 것에 대한 대안
>
> `mock`, `stub`, `fake`

앞서 살펴본 것처럼 코드의 모든 동작을 완벽하게 테스트하기 위해 종종 입력을 설정하고 부수 효과를 검증해야 한다.

👉🏻 하지만 테스트에서 의존성을 실제로 테스트하는 것이 항상 가능하거나 바람직한 것은 아니다.

## 10.4.1 테스트 더블을 사용하는 이유

1. **테스트 단순화**  
   의존성을 실제로 사용하는 대신 테스트 더블을 사용하면 작업이 단순해진다.

2. **테스트로부터 외부 세계 보호**  
   외부 세계에 있는 시스템을 테스트의 동작으로부터 보호할 수 있다.

3. **외부로부터 테스트 보호**
   항상 동일하게 결정적 방식으로 작동하도록 설정할 수 있다.

### 테스트 단순화

테스트 더블을 사용하면, 실제 의존성을 설정하거나 하위 종속성에서 무언가를 검증할 필요가 없다.

하지만 테스트 더블을 사용할 때 **오히려 구현 세부 정보와 더 연관되는 상황**이 있을 수 있다. _(ex. `mock`에서의 내부 메소드 호출 여부 검사 등)_  
또한, 의존성을 실제로 사용하는 것보다 더 복잡할 때도 있으므로, 테스트 더블의 사용 여부는 **사례별로 고려되어야** 한다.

### 테스트로부터 외부 세계 보호

의존성으로 인해 부수효과가 발생한다면, 테스트 더블을 사용하는 것이 좋다.

- ex. 은행 계좌 관리

은행 계좌 관리에 대한 의존성을 실제 객체로 설정하게 되면, 실제 운영 서버에서 테스트 내용이 반영될 것이다.

그 뿐만 아니라, 모니터링 및 로깅에도 영향을 미칠 수 있기 때문에 개발자에게 혼란을 줄 수 있다.

### 외부로부터 테스트 보호

예를 들어 `데이터베이스에서 정기적으로 변경되는 값`을 읽거나, `난수 생성기`를 사용하여 ID와 같은 것들을 생성하는 실제 의존성이 있을 수 있다.

- 이러한 의존성을 테스트에 사용하면, **테스트 결과를 신뢰하기 어려울** 때가 있다.

이처럼 의존성을 실제로 사용하는 것이 바람직하지 않거나 현실적으로 가능하지 않은 경우가 존재한다.  
👉🏻 이때 `테스트 더블` 사용을 고려할 수 있다.

## 10.4.2 Mock

> **Mock**  
> **의존성을 통해 제공되는 함수를 호출하는지** 검증하기 위해 사용할 수 있음

목은 클래스나 인터페이스를 시뮬레이션하는 데 `멤버 함수에 대한 호출`을 기록하는 것 외에는 어떠한 일도 수행하지 않는다.

## 10.4.3 Stub

> **Stub**  
> 의존하는 코드로부터 **어떤 값을 받아야 하는 경우**, 그 의존성을 시뮬레이션 하는 데 사용할 수 있음

함수가 호출되면 **미리 정해 놓은 값을 반환**함으로써 함수를 시뮬레이션 한다.

- 스텁에서는 함수가 호출될 때마다 미리 정해진 값을 리턴하도록 설정할 수 있다.

## 10.4.4 목과 스텁은 문제가 될 수 있다

- 목이나 스텁이 실제 의존성과 다른 방식으로 동작하도록 설정되면, 테스트는 실제적이지 않다.
- 구현 세부 사항과 테스트가 밀접하게 결합하여 리팩터링이 어려워질 수 있다.

### 목과 스텁은 실제적이지 않은 테스트를 만들 수 있다

목이나 스텁을 사용할 때, 개발자는 목이나 스텁이 어떻게 동작할지 결정해야 한다.  
이때, 클래스나 함수가 실제와 다르게 동작하도록 하는 것은 아주 위험하다.

- **실제 의존성이 어떻게 동작하는지 이해**하지 못하면, 목을 설정할 때 실수할 가능성이 커진다.

### 목과 스텁을 사용하면 테스트가 구현 세부 정보에 유착될 수 있다

```java
void testSettleInvoice_positiveBalance() {
    // ...
    verifyThat(mockAccount.debit)
        .wasCalledOnce()
        .withArguments(invoiceBalance);
}

void testSettleInvoice_negativeInvoiceBalance() {
    // ...
    verifyThat(mockAccount.credit)
        .wasCalledOnce()
        .withArguments(invoiceBalance.absoluteAmount());
}
```

위 코드는 mock을 통해서 `debit` 메서드와 `credit` 메서드의 호출 여부를 검사한다.

- 이는 송금 과정이 `어떻게` 이루어지는지를 드러내고 있다.

👉🏻 즉, `구현 세부 사항`을 노출하고 있다.

테스트는 구현 세부 사항에 구애받지 않아야 한다.  
실제 의존성이나 `fake`를 사용하는 것이 가능하다면, 그렇게 하는 것이 보통 더 바람직하다.

## 10.4.5 Fake

> **Fake**  
> 실제 의존성의 공개 API를 **정확하게 시뮬레이션** 한다. 이때, 외부와 통신하는 대신 페이크 내의 **멤버 변수에 상태를 저장**한다.

클래스의 대체 구현체로, 테스트에서 안전하게 사용할 수 있다.

페이크의 요점은 코드 계약이 실제 의존성과 동일하므로, 실제 클래스가 특정 입력을 받아들이지 않는다면 **페이크도 마찬가지라는 것**이다.

- 다만, 이는 실제 의존성에 대한 코드를 유지보수하는 팀이 `페이크 코드도 같이 유지보수 한다`는 전제 하에 성립 가능하다.

### 페이크로 인해 보다 실질적인 테스트가 이루어질 수 있다

### 페이크를 사용하면 구현 세부정보로부터 테스트를 분리할 수 있다

목이나 스텁 대신 페이크를 사용하는 이점은, **테스트가 구현 세부 사항에 밀접하게 결합하는 정도가 덜하다**는 것이다.

앞서 목을 사용하여 `debit()`, `credit()` 함수가 호출되는지를 확인하며 구현 세부 사항에 결합되는 것을 확인할 수 있었다.

이와 대조적으로 페이크를 사용하는 경우에는 구현 세부사항 대신, `최종 결과가 정확한지` 확인한다.

## 10.4.6 목에 대한 의견

- 목 찬성론자
- 고전주의자
  - 테스트에서 의존성을 **실제로 사용하는 것을 최우선으로 해야한다**고 주장한다.
  - 실제 의존성을 사용하는 것이 불가능할 때, `페이크`를 사용하는 것을 선호한다.

목 접근법은 시험 대상 코드가 `어떻게 하는가`를 확인하는 반면, 고전주의 접근법은 코드를 실행하는 `최종 결과가 무엇인지` 확인하는 경향이 있다.

고전주의적 접근법에 찬성하고 목 접근법에 반대하는 주장은 다음과 같다.

- 목은 코드가 특정 호출을 하는지만 확인할 뿐, 실제로 호출이 유효한지는 검증하지 않는다.
- 고전적인 접근법에서는 **최종 결과**, 즉 코드가 반환하는 것이나 결과 상태를 검증하는 데 중점을 둔다.
  - 구현 세부 사항에 대해 더 독립적인 테스트가 가능하다.

# 10.5 테스트 철학으로부터 신중하게 선택하라

- **테스트 주도 개발**
  - 실제 코드를 작성하기 전에 테스트 케이스를 먼저 작성하는 것을 지지한다.
- **행동 주도 개발**
  - 사용자, 고객, 비즈니스의 관점에서 소프트웨어가 보여야 할 행동(또는 기능)을 식별하는 데 집중하는 것이다.
- **수용 테스트 주도 개발**

중요한 것은 좋은 품질의 테스트 코드를 철저하게 작성하고 고품질의 소프트웨어를 생산하는 것이다.
