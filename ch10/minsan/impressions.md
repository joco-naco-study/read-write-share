그동안 스텁이나 페이크도 목으로 통칭했는데, 이번 장을 통해 셋의 구분을 명확히 할 수 있었다.

특히나 지난 프로젝트에서 Mock을 이용하여 단위 테스트를 구현했을 때 떠올랐던 많은 의문점들이 이번 장을 통해 해소된 것 같다.

- 예를 들어, Mock에 너무 의존하다보니 `실제 의존성을 갖는 코드가 제대로 동작하는지`도 확인할 수 없는 경우가 많았다. _(테스트 코드가 Mock의 실행 결과만 보여주는 꼴?이 되어버림)_
  - 하지만, 실제 서비스에 영향을 주거나 하위 의존성이 복잡하지 않은 경우에는 **실제 의존성을 갖는 상태에서 테스트 하는 것이 좋겠다**는 생각이 든다.
  - 실제 서비스에 영향을 주거나 하위 의존성이 복잡한 경우, Mock 대신 `Fake`를 사용하는 것이 좋을 것 같다.

# 요약

- 코드베이스에 제출된 거의 모든 '실제 코드'는 그에 해당하는 단위 테스트가 동반되어야 한다.
- '실제 코드'가 보여주는 모든 동작에 대해 이를 실행해보고 결과를 확인하는 테스트 케이스가 작성되어야 한다.  
  아주 간단한 테스트 케이스가 아니라면, 각 테스트 케이스 코드는 준비, 실행, 단언 (혹은 given, when, then)의 세 가지 부분으로 나누는 것이 일반적이다.
- 바람직한 단위 테스트의 주요 특징은 다음과 같다.
  1. 문제가 생긴 코드의 정확한 탐지
  2. 구현 세부 정보에 구애받지 않음
  3. 실패가 잘 설명됨
  4. 이해하기 쉬운 테스트 코드
  5. 쉽고 빠르게 실행
- 테스트 더블은 의존성을 실제로 사용하는 것이 불가능하거나 현실적으로 어려울 때 단위 테스트에 사용될 수 있다. 테스트 더블의 몇 가지 예는 다음과 같다.
  - 목
  - 스텁
  - 페이크
- 목 및 스텁을 사용한 테스트 코드는 비현실적이고 구현 세부 정보에 밀접하게 연결될 수 있다.
- 목과 스텁의 사용에 대한 여러 의견이 있다.  
  필자의 의견은 **가능한 한 실제 의존성이 테스트에 사용되어야 한다**는 것이다. 이렇게 할 수 없다면, 페이크가 차선책이고, 목과 스텁은 최후의 수단으로만 사용되어야 한다.

# 페이크는 테스트 대상 코드와 같이 유지보수 되어야 한다

책에서는 페이크의 단점에 대해서는 크게 소개되지 않았는데, 이 부분이 어떻게 보면 페이크의 단점으로 볼 수 있을 것 같다.

페이크는 개발자가 대상 코드에 기반하여 직접 테스트 객체를 생성하는 것이다.

- 이는 즉, 대상 코드가 변하면 페이크 객체도 변해야 한다는 뜻이다.

예를들어 대상 코드에서 새로운 예외 처리가 추가된 경우, **페이크 객체는 영향을 받지 않기** 때문에 이를 사용한 테스트 코드는 정상적으로 실행될 것이다.

👉🏻 이는 결국 유지보수 해야할 부분이 하나 더 늘어난다는 의미이기도 하다.
