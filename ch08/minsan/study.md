# Chapter 8: 코드를 모듈화하라

`모듈화`의 주된 목적 중 하나는 코드가 향후에 어떻게 변경되거나 재구성될지 정확히 알지 못한 상태에서 **변경과 재구성이 용이한 코드를 작성하는 것**이다.

- 이를 달성하기 위한 핵심 목표는 **각각의 기능**이 코드베이스의 **서로 다른 부분에서 구현되어야 한다**는 것
  - 👉🏻 요구사항이 바뀌면 관련된 부분만 수정하면 됨

# 8.1 의존성 주입의 사용을 고려하라

의존성 주입은 **하위 문제를 재구성**할 수 있게 한다.

## 8.1.1 하드 코드화된 의존성은 문제가 될 수 있다

생성자 내부에서 직접 의존하는 객체를 생성해서 주입(= 하드 코딩된 의존성)하면,

- 다른 구현으로 코드를 재설정할 수 없다.
- 의존하는 객체가 매개변수를 가질 경우, 해당 매개변수에 대해서도 처리해야 한다.
  - 👉🏻 결합도가 증가함

> 👉🏻 `모듈화`되지 않은 코드는 다용도로 사용할 수 없다.

## 8.1.2 해결책: 의존성 주입을 사용하라

특히 `팩토리 함수`를 사용하면, **의존성으로 주입할 기본 객체들**을 따로 관리할 수 있다.

- 팩토리 패턴 대신, `의존성 주입 프레임워크`를 사용할 수 있음

## 8.1.3 의존성 주입을 염두에 두고 코드를 설계하라

의존성 주입이 아닌, `정적 함수`를 사용한다면 어떨까?

- **상위 코드 계층에서** 하위 문제에 대해 **설정을 달리하고자 한다면** 문제가 될 수 있다.
- 이는 `static cling`의 원인이 될 수도 있음

대개 다른 해결책이 필요할 때가 있을 것이라는 생각이 든다면, `추상화`를 적용하여 구현을 분리할 것이다.  
이처럼 **하위 문제에 대한 해결책이 여러 개** 있는 경우, `의존성 주입`을 통해 다양한 시나리오에도 적용 가능하도록 설계할 수 있다.

# 8.2 인터페이스에 의존하라

`인터페이스`에 의존하면, 어떤 구현 클래스라도 사용할 수 있기 때문에 **훨씬 더 모듈화되고 적응성이 높아**진다.

## 8.2.1 구체적인 구현에 의존하면 적응성이 제한된다

## 8.2.2 해결책: 가능한 경우 인터페이스에 의존하라

> **의존성 역전 법칙 (DIP)**  
> 👉🏻 구현보다 추상화에 의존하라

# 8.3 클래스 상속을 주의하라

두 사물이 진정한 `is-a 관계`를 갖는다면, 상속이 적절할 수 있다.

하지만, 상속을 사용할 수 있는 상황에서 많은 경우 **구성(composition)** 을 상속 대신 사용할 수 있다.

- 즉, 클래스를 확장하기보단 **인스턴스를 가지고 있음으로써** 한 클래스를 다른 클래스로부터 구성할 수 있다.

> 👉🏻 구성이라는 의미가 잘 와닿지 않았는데, 책 내용을 읽어보니 `extends` 보다는 `멤버 변수(= 인스턴스)`로 참조해서 **기능을 직접 사용하도록** 하라는 의미인 것 같다.

## 8.3.1 클래스 상속은 문제가 될 수 있다

### 상속은 추상화 계층에 방해가 될 수 있다

자식 클래스가 부모 클래스의 기능을 상속하면서, 원하는 것보다 더 많은 기능을 노출하게 될 수 있다.

- 이로 인해 추상화 계층이 복잡해지고 **구현 세부 정보가 드러날 수 있음**
- 또한, 상속을 통해 **부모 클래스의 함수들이 의도치 않게 외부에 공개**될 수 있음

### 상속은 적응성 높은 코드의 작성을 어렵게 만들 수 있다

간단한 요구사항 변동이 발생하더라도, 상속을 사용하는 경우에는 코드 변경이 어려워질 수 있다.

## 8.3.2 해결책: 구성을 사용하라

👉🏻 클래스를 확장하기보다는 해당 클래스의 `인스턴스`를 가지고 있음으로써 하나의 클래스를 다른 클래스로부터 구성한다는 것을 의미한다.

### 더 간결한 추상화 계층

클래스가 인터페이스로 명시하지 않는 한, 의도치 않게 외부에 세부 구현이 노출되지 않는다.

### 적응성이 높은 코드

`추상화`와 `의존성 주입`을 통해 구현체를 쉽게 변경할 수 있다.

## 8.3.3 진정한 is-a 관계는 어떤가?

진정한 `is-a 관계`가 있다고 하더라도 **상속은 여전히 문제가 될 수 있다.**

- 취약한 베이스 클래스 문제
  - 슈퍼클래스가 수정되면 자식 클래스에 영향을 미칠 수 있음
- 다이아몬드 문제
  - **다중 상속**을 할 때, 여러 슈퍼 클래스가 **서로 동일한 함수를 제공하는 경우**, 어느 슈퍼 클래스의 함수를 상속하는지 모호해짐
- 문제가 있는 계층 구조

하지만 때로는 계층 구조를 피할 수 없는 경우도 존재한다. 상속을 대신해서 계층 구조를 달성하기 위해 다음과 같은 것들을 할 수 있다.

- `인터페이스`를 사용하여 계층 구조 정의  
   👉🏻 **계층 구조**
- `구성`을 사용하여 코드 재사용 _(= 의존성 주입)_  
  👉🏻 **코드 재사용**

# 8.4 클래스는 자신의 기능에만 집중해야 한다

모듈화의 핵심 목표 중 하나는 요구사항이 변경되면 **그 변경과 직접 관련된 코드만 수정한다는 것**이다. _(= 높은 응집도)_

이와 반대되는 상황은 **하나의 개념이 여러 클래스에 분산되는 경우**다.

- 다른 클래스의 세부 사항에 지나치게 연관되어 있을 때 이런 일이 발생할 수 있다.

## 8.4.1 다른 클래스와 지나치게 연관되어 있으면 문제가 될 수 있다.

## 8.4.2 해결책: 자신의 기능에만 충실한 클래스를 만들라

오브젝트에서 말한 **"자율적인 객체를 만들라"** 는 것과 똑같은 이야기임

# 8.5 관련있는 데이터는 함께 캡슐화하라

서로 다른 데이터가 서로 밀접하게 연관되어 있어 그것들이 항상 함께 움직여야할 때, 이를 함께 캡슐화하는 것이 좋다.

## 8.5.1 캡슐화되지 않은 데이터는 취급하기 어려울 수 있다

## 8.5.2 해결책: 관련된 데이터는 객체 또는 클래스로 그룹화하라

여러 데이터가 따로 떨어져서는 별 의미가 없을 정도로 서로 밀접하게 연관되어 있거나, 캡슐화된 데이터 중에서 일부만 원하는 경우가 아니라면 캡슐화하는 것이 합리적이다.

# 8.6 반환 유형에 구현 세부 정보가 유출되지 않도록 주의하라

## 8.6.1 반환 형식에 구현 세부 사항이 유출될 경우 문제가 될 수 있다

함수 실행 과정에서 HTTP 통신이 발생하는 것을 **외부에 알릴 필요가 없음**에도 반환 타입을 `HttpResponse`로 명시하는 경우를 예시로 볼 수 있다.

## 8.6.2 해결책: 추상화 계층에 적합한 유형을 반환하라

앞에서 언급한 예시를 그대로 가져온다면,

- 개발자가 실제로 **신경 써야 할 상태만** 열거형으로 정의해서 반환한다.

즉, **외부로 노출할 개념을 최소화하는 유형**을 새로 정의해서 사용하면, 좀 더 모듈화된 코드와 간결한 추상화 계층을 얻을 수 있다.

# 8.7 예외 처리 시 구현 세부 사항이 유출되지 않도록 주의하라

## 8.7.1 예외 처리 시 구현 세부 사항이 유출되면 문제가 될 수 있다

## 8.7.2 해결책: 추상화 계층에 적절한 예외를 만들라

`Exception` 클래스를 적절히 **상속**해서 적절한 예외를 정의하여 사용하는 것이 좋다.
