# Chapter 06: 예측 가능한 코드를 작성하라

**함수가 아무것도 반환하지 않을 때가 있거나**, **처리해야 할 특별한 시나리오가 있는 경우** 이 사실을 다른 개발자에게 확실히 알려야 한다.

## 6.1 매직 값을 반환하지 말아야 한다

> **매직값**  
> 함수의 정상적인 반환 유형에 적합하지만, 특별한 의미를 가지고 있는 값

매직값은 함수의 정상적인 반환 유형에 들어맞기 때문에, 이 값이 갖는 특별한 의미를 인지하지 못하고, 정상적인 반환 값으로 오인하기 쉽다.

### 6.1.1 매직값은 버그를 유발할 수 있다

만일 **단위 테스트**를 작성한다고 하더라도, 매직값과 관련된 `예외 상황`을 고려하지 못한 채 테스트를 작성할 가능성이 존재한다.

### 6.1.2 해결책: 널, 옵셔널 또는 오류를 반환하라

호출하는 쪽에서 `값이 없을 수 있음`을 인지하고, **적절한 방법으로 이를 처리할 수 있게** 해야한다.

하지만, `널 값`이나 비어 있는 `옵셔널`을 반환하는 것의 단점은 `값이 없는 이유를 명시적으로 전달하지 않는다`는 점이다.

- 사용자의 나이가 값을 제공하지 않아서?
- 시스템에서 오류가 발생해서?

> 👉🏻 이러한 상황을 구별하는 것이 필요하다면, `4장`에서 설명한 `오류 전달 기법`의 사용을 고려해야 한다.

```md
[ 널 리턴은 호출 쪽에 부담을 주지 않는가? ]

이에 대한 대답은 종종 그렇다는 것이다. 함수가 널 값을 반환할 수 있다면, 호출하는 쪽에서는 값이 널인 경우를 처리하기 위해 코드를 추가로 작성해야 할 때가 많다.

이러한 문제점으로 인해, 널 값의 대안으로 `널 객체 패턴`을 제시하기도 한다.

- 하지만 이것 역시 부적절하게 사용하면 문제가 될 수 있다.
```

### 6.1.3 때때로 매직값이 우연히 발생할 수 있다

매직값 반환이 반드시 개발자의 의도에 의해서만 되는 것은 아니다.

개발자가 자신의 코드에 주어지는 **모든 입력**과, **이러한 입력 값들이 어떤 영향을 미칠 수 있을지**에 대해 충분히 생각하지 않을 때도 매직값은 반환될 수 있다.

```java
public int minValue(List<Integer> values) {
    int minValue = Integer.MAX_VALUE;
    for (int value : values) {
        minValue = Math.min(value, minValue);
    }
    return minValue;
}
```

👉🏻 이 코드의 문제점은 `함수가 어떻게 호출`되고 `결과가 어떻게 사용될지`에 대해 **가정을 한다는 것**이다.

만약에 빈 리스트가 주어진다면, 최소값으로 `Integer.MAX_VALUE`를 반환할 것이다.

- 이는 암묵적으로 **`호출하는 쪽의 상황`에 대해서 많은 것을 가정하고 있다.**

이러한 경우에는 `널`이나 `옵셔널`을 리턴하여, 차라리 호출하는 쪽에 추가적인 부담을 주는 것이 더 낫다. _(위험을 없애주기 때문)_

```java
public int minValue(List<Integer> values) {
    if (values.isEmpty() == 0) {
        return null;
    }
    int minValue = Integer.MAX_VALUE;
    for (int value : values) {
        minValue = Math.min(value, minValue);
    }
    return minValue;
}
```

> 👉🏻 매직값보다는 `널값`이나 `옵셔널`을 반환하거나, `오류 전달 기술`을 사용하는 것이 간단하고 효과적인 대안이다.

## 6.2 널 객체 패턴을 적절히 사용하라

값을 얻을 수 없을 때, `널 값`이나 빈 `옵셔널`을 반환하는 대신 `널 객체 패턴`을 사용할 수 있다.

- 이를 사용하는 이유는, **그 이후에 실행되는 로직**에서 `널 값`으로 인해 `시스템에 피해가 가지 않도록` 하기 위함이다.

하지만 이를 부적절하게 사용하면 예측을 벗어나는 동작을 하거나 발견하기 어려운 미묘한 버그가 발생할 수 있다.

### 6.2.1 빈 컬렉션을 반환하면 코드가 개선될 수 있다

함수가 리스트, 집합, 배열과 같은 컬렉션을 반환할 때, 컬렉션의 값을 얻을 수 없는 경우가 있다.

```java
public Set<String> getClassNames(HtmlElement element) {
    String attribute = element.getAttribute("class");
    if (attribute == null) {
        return null;
    }
    return new Set(attribute.split(" "));
}

public Boolean isElementHighlighted(HtmlElement element) {
    Set<String> classNames = getClassNames(element);
    if (classNames == null) {
        return false;
    }
    return classNames.contains("highlighted");
}
```

- **class 속성이 지정되지 않은 경우** `널 값`을 반환
- **class 속성이 지정되었으나 비어있는 경우** `빈 집합`을 반환

하지만 해당 함수를 사용하는 경우를 떠올렸을 때, **이 두 가지를 구별하는 것은 큰 의미가 없다.**

> 👉🏻 이런 상황에서는 `널 객체 패턴`을 사용해서 코드를 개선할 수 있다.

```java
public Set<String> getClassNames(HtmlElement element) {
    String attribute = element.getAttribute("class");
    if (attribute == null) {
        return new Set();
    }
    return new Set(attribute.split(" "));
}

public Boolean isElementHighlighted(HtmlElement element) {
    return getClassNames(element).contains("highlighted");
}
```

이로 인해 호출하는 쪽의 코드는 간단해지고, 코드가 예측을 벗어나는 동작을 할 가능성이 매우 낮아졌다.

### 6.2.2 빈 문자열을 반환하는 것도 때로는 문제가 될 수 있다

문자열이 **단순히 문자들을 모아 놓은 것이 아닌, 그 이상의 의미를 지닐 때**는 널 대신 `빈 문자열을 반환하는 것이 문제가 될 수 있다`.

> 👉🏻 널 객체로 발생할 수 있는 `서로 다른 의미`를 구별하는 의미가 크지 않다면, 빈 문자열을 사용해도 괜찮다.
>
> 👉🏻 하지만, **`null`이 갖는 의미**가 분명하다면 **`null`을 그대로 반환하는 것**이 좋다.

### 6.2.3 더 복잡한 널 객체는 예측을 벗어날 수 있다

호출하는 쪽에서 `널 객체를 받고 놀라거나 황당해할 가능성`이 있다면, 널 객체 패턴은 **피하는 것이 가장 좋다.**

`Optional` 값을 리턴하면, 코드 계약을 통해 널 값이 리턴될 수 있음을 호출하는 쪽에서도 충분히 예측할 수 있다.

### 6.2.4 널 객체 구현은 예상을 벗어나는 동작을 유발할 수 있다.

**널 객체 패턴**을 사용하거나 접할 때, `그것이 정말 적절한지` 혹은 `예상을 벗어나는 동작을 할 가능성이 있는지`에 대해 **의식적으로 생각해봐야 한다.**

- 하지만, `널 안정성`과 `옵셔널`이 등장함에 따라서 널 객체 패턴 사용을 지지하는 주장들 중 많은 것들이 설득력이 떨어지기도 했다.

## 6.3 예상치 못한 부수 효과를 피하라

> **불변 클래스**  
> 👉🏻 클래스를 불변(immutable)으로 만드는 것은 **부수 효과의 가능성을 최소화**하는 좋은 방법이 될 수 있다.

부수 효과가 원하는 기능의 일부이거나 **피할 수 없는 경우**, **호출하는 쪽에서 이를 확실히 인지하도록 하는 것**이 중요햐다.

### 6.3.1 분명하고 의도적인 부수 효과는 괜찮다

### 6.3.2 예기치 않은 부수 효과는 문제가 될 수 있다

`함수의 이름`에 **부수 효과**를 명확히 드러내지 않는다면, 호출하는 쪽에서는 이를 예측하기 어렵다.

- 부수 효과는 비용이 많이 들 수 있음
  - 호출하는 쪽에서는 간단한 연산을 예측하고 썼음에도, 이와 상반되는 결과를 마주하게 됨
- 호출한 쪽의 가정을 깨뜨릴 수 있음
- 다중 스레드에서 버그를 일으킬 수 있음
  - 한 스레드로 인한 부수 효과는 다른 스레드에 문제를 일으킬 수 있음

### 6.3.3 해결책: 부수 효과를 피하거나 그 사실을 분명히 하라

부수 효과가 불가피하다면, `함수 이름`으로 `부수효과`를 명확히 드러내어 **호출하는 쪽에서 이를 예측할 수 있도록** 해야 한다.

## 6.4 입력 매개변수를 수정하는 것에 주의하라

### 6.4.1 입력 매개변수를 수정하면 버그를 초래할 수 있다.

특히 **얕은 복사**로 전달되는 컬렉션같은 경우에는 특히 주의해야 한다.

### 6.4.2 해결책: 변경하기 전에 복사하라

하지만, 성능을 고려하여 변경이 불가피한 경우가 있을 수 있다.

- 컬렉션에서 정렬해야하는 값이 너무 많은 경우

이때도 마찬가지로 함수명에 이러한 사실을 명백히 드러내야 한다.

## 6.5 오해를 일으키는 함수는 작성하지 마라

### 6.5.1 중요한 입력이 누락되었을 때 아무것도 하지 않으면 놀랄 수 있다

입력 값이 `null`로 주어진 경우, **함수 내에서 아무것도 안 하고 종료하는 경우**가 있다.

- 호출하는 쪽의 부담을 줄여주기 위한 목적에서 사용하는 경우가 많다.

👉🏻 하지만, 이러한 코드는 예상치 못한 결과를 초래할 수 있다.

## 6.6 미래를 대비한 열거형 처리

우리가 의존하는 코드에 대해 `부실한 가정`을 할 경우에도, `우리의 예상을 벗어나는 결과`를 초래할 수 있다.

- 열거형을 처리하는 경우, 나중에 `열거형에 더 많은 값이 추가될 수 있다`는 점을 기억하는 것이 중요하다.

### 6.6.1 미래에 추가될 수 있는 열것값을 암묵적으로 처리하는 것은 문제가 될 수 있다

때때로 개발자들은 열거형 내의 현재 값을 보고 **_"if문 사용해서 처리할 수 있겠다"_** 고 생각한다.

- 하지만 이는 `나중에 다른 값이 추가될 경우` 문제가 될 수 있다.

```java
public enum PredictedOutcome {
    COMPANY_WILL_GO_BUST,
    COMPANY_WILL_MAKE_A_PROFIT,
    ;
}

public Boolean isOutcomeSafe(PredictedOutcome prediction) {
    if (prediction == PredictedOutcome.COMPANY_WILL_GO_BUST) {
        return false;
    }
    return true;
}
```

👉🏻 이 코드는 얼것값이 2개인 동안에만 정상 동작한다.

### 6.6.2 해결책: 모든 경우를 처리하는 스위치 문을 사용하라

모든 열것값을 명시적으로 처리하고, `처리되지 않은 새로운 열것값이 추가되는 경우`에는 **코드 컴파일이 실패하거나 테스트가 실패하게 하는 것**이다.

```java
public enum PredictedOutcome {
    COMPANY_WILL_GO_BUST,
    COMPANY_WILL_MAKE_A_PROFIT,
    ;
}

public Boolean isOutcomeSafe(PredictedOutcome prediction) {
    switch (prediction) {
        case COMPANY_WILL_GO_BUST:
            return false;
        case COMPANY_WILL_MAKE_A_PROFIT:
            return true;
    }
    throw new UncheckedException(
        "Unhandled prediction: " + prediction
    );
}
```

그리고 이를 확인할 수 있는 단위 테스트를 아래와 같이 추가할 수 있다.

```java
for (PredictedOutcome prediction : PredictedOutcome.values()) {
    isOutcomeSafe(prediction);
}
```

### 6.6.3 기본 케이스를 주의하라

스위치 문에 기본 케이스(`default`)를 추가하면, 향후 열거형 값이 암시적으로 처리될 수 있으며 잠재적으로 예기치 않은 문제와 버그가 발생할 수 있다.

`예외처리`도 마찬가지로 default 대신 위의 예시 코드처럼 `스위치 외부`에서 처리하는 것이 더 낫다.

### 6.6.4 주의 사항: 다른 프로젝트의 열거형에 의존

## 6.7 이 모든 것을 테스트할 수는 없는가?

- 충분한 시나리오나 코너 케이스를 테스트하지 않을 수 있다.
- 자신이 생각하는대로 테스트 코드를 작성한다.
  - 목 객체 자체를 올바르게 프로그래밍 하지 못할 수 있다.
- 멀티스레딩 문제와 관련된 버그는 예측 및 테스트가 어렵다

테스트는 매우 중요하지만, 현실적으로 예상을 벗어나는 코드에 `숨어있는 오류`를 테스트만으로 방지하기는 매우 어렵다.
